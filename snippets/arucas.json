{
  "Function debug(bool)": {
    "prefix": "debug($bool)",
    "body": "debug($bool)",
    "description": "debug(bool)\nThis is used to enable or disable debug mode.\n- Parameter - Boolean (`bool`): True to enable debug mode, false to disable debug mode.\n"
  },
  "Function eval(code)": {
    "prefix": "eval($code)",
    "body": "eval($code)",
    "description": "eval(code)\nThis is used to evaluate a string as code.\nThis will not inherit imports that are in the parent script.\n- Parameter - String (`code`): The code to evaluate.\n"
  },
  "Function experimental(bool)": {
    "prefix": "experimental($bool)",
    "body": "experimental($bool)",
    "description": "experimental(bool)\nThis is used to enable or disable experimental mode.\n- Parameter - Boolean (`bool`): True to enable experimental mode, false to disable experimental mode.\n"
  },
  "Function getArucasVersion()": {
    "prefix": "getArucasVersion()",
    "body": "getArucasVersion()",
    "description": "getArucasVersion()\nThis is used to get the version of Arucas that is currently running.\n"
  },
  "Function getDate()": {
    "prefix": "getDate()",
    "body": "getDate()",
    "description": "getDate()\nThis is used to get the current date formatted with dd/MM/yyyy in your local time.\n"
  },
  "Function getMilliTime()": {
    "prefix": "getMilliTime()",
    "body": "getMilliTime()",
    "description": "getMilliTime()\nThis is used to get the current time in milliseconds.\n"
  },
  "Function getNanoTime()": {
    "prefix": "getNanoTime()",
    "body": "getNanoTime()",
    "description": "getNanoTime()\nThis is used to get the current time in nanoseconds.\n"
  },
  "Function getTime()": {
    "prefix": "getTime()",
    "body": "getTime()",
    "description": "getTime()\nThis is used to get the current time formatted with HH:mm:ss in your local time.\n"
  },
  "Function getUnixTime()": {
    "prefix": "getUnixTime()",
    "body": "getUnixTime()",
    "description": "getUnixTime()\nThis is used to get the current time in seconds since the Unix epoch.\n"
  },
  "Function input(prompt)": {
    "prefix": "input($prompt)",
    "body": "input($prompt)",
    "description": "input(prompt)\nThis is used to take an input from the user. The execution of\nthe script is paused until the user has inputted a value.\n- Parameter - String (`prompt`): The prompt to show the user.\n"
  },
  "Function isDebug()": {
    "prefix": "isDebug()",
    "body": "isDebug()",
    "description": "isDebug()\nThis is used to determine whether the interpreter is in debug mode.\n"
  },
  "Function isExperimental()": {
    "prefix": "isExperimental()",
    "body": "isExperimental()",
    "description": "isExperimental()\nThis is used to determine whether the interpreter is in experimental mode.\n"
  },
  "Function isMain()": {
    "prefix": "isMain()",
    "body": "isMain()",
    "description": "isMain()\nThis is used to check whether the script is the main script.\n"
  },
  "Function len(sizable)": {
    "prefix": "len($sizable)",
    "body": "len($sizable)",
    "description": "len(sizable)\nThis is used to get the length of a collection or string.\n- Parameter - String (`sizable`): The collection or string.\n"
  },
  "Function print(value)": {
    "prefix": "print($value)",
    "body": "print($value)",
    "description": "print(value)\nThis prints a number of values to the console.\nIf there are no arguments then this will print a new line,\nother wise it will print the contents without a new line.\n- Parameter - Object (`value...`): The value to print.\n"
  },
  "Function printDebug(value)": {
    "prefix": "printDebug($value)",
    "body": "printDebug($value)",
    "description": "printDebug(value)\nThis logs something to the debug output.\nIt only prints if debug mode is enabled: `debug(true)`.\n- Parameter - Object (`value`): The value to print.\n"
  },
  "Function random(bound)": {
    "prefix": "random($bound)",
    "body": "random($bound)",
    "description": "random(bound)\nThis is used to generate a random integer between 0 and the bound.\n- Parameter - Number (`bound`): The maximum bound (exclusive).\n"
  },
  "Function range(bound)": {
    "prefix": "range($bound)",
    "body": "range($bound)",
    "description": "range(bound)\nThis is used to generate a range of integers starting from 0, incrementing by 1.\n- Parameter - Number (`bound`): The maximum bound (exclusive).\n"
  },
  "Function range(start, bound)": {
    "prefix": "range($start, $bound)",
    "body": "range($start, $bound)",
    "description": "range(start, bound)\nThis is used to generate a range of numbers starting\nfrom a start value and ending at a bound value incrementing by 1.\n- Parameter - Number (`start`): The start value.\n- Parameter - Number (`bound`): The maximum bound (exclusive).\n"
  },
  "Function range(start, bound, step)": {
    "prefix": "range($start, $bound, $step)",
    "body": "range($start, $bound, $step)",
    "description": "range(start, bound, step)\nThis is used to generate a range of numbers starting from a\nstart value and ending at a bound value incrementing by a step value.\n- Parameter - Number (`start`): The start value.\n- Parameter - Number (`bound`): The maximum bound (exclusive).\n- Parameter - Number (`step`): The step value.\n"
  },
  "Function run(path)": {
    "prefix": "run($path)",
    "body": "run($path)",
    "description": "run(path)\nThis is used to run a .arucas file, you can use on script to run other scripts.\n- Parameter - String (`path`): As a file path.\n"
  },
  "Function runFromString(code)": {
    "prefix": "runFromString($code)",
    "body": "runFromString($code)",
    "description": "runFromString(code)\nThis is used to evaluate a string as code.\nThis will not inherit imports that are in the parent script.\n- Parameter - String (`code`): The code to run.\n"
  },
  "Function sleep(milliseconds)": {
    "prefix": "sleep($milliseconds)",
    "body": "sleep($milliseconds)",
    "description": "sleep(milliseconds)\nThis pauses your program for a certain amount of milliseconds.\n- Parameter - Number (`milliseconds`): The number of milliseconds to sleep.\n"
  },
  "Function stop()": {
    "prefix": "stop()",
    "body": "stop()",
    "description": "stop()\nThis is used to stop a script.\n"
  },
  "Function suppressDeprecated(bool)": {
    "prefix": "suppressDeprecated($bool)",
    "body": "suppressDeprecated($bool)",
    "description": "suppressDeprecated(bool)\nThis is used to enable or disable suppressing deprecation warnings.\n- Parameter - Boolean (`bool`): True to enable, false to disable warnings.\n"
  },
  "Function hold()": {
    "prefix": "hold()",
    "body": "hold()",
    "description": "hold()\nThis freezes the current thread and halts execution, same functionality as 'Thread.freeze()'.\n"
  },
  "Biome Class": {
    "prefix": "Biome",
    "body": "Biome",
    "description": "The Biome class from Minecraft.\nThis class represents biomes, and allows you to interact with things inside of them.\n"
  },
  "Method <Biome>.canSnow(pos)": {
    "prefix": ".canSnow($pos)",
    "body": ".canSnow($pos)",
    "description": "<Biome>.canSnow(pos)\nThis function calculates whether snow will fall at given coordinates.\n- Parameter - Pos (`pos`): The position.\n"
  },
  "Method <Biome>.canSnow(x, y, z)": {
    "prefix": ".canSnow($x, $y, $z)",
    "body": ".canSnow($x, $y, $z)",
    "description": "<Biome>.canSnow(x, y, z)\nThis function calculates whether snow will fall at given coordinates.\n- Parameter - Number (`x`): The x coordinate.\n- Parameter - Number (`y`): The y coordinate.\n- Parameter - Number (`z`): The z coordinate.\n"
  },
  "Method <Biome>.getFogColor()": {
    "prefix": ".getFogColor()",
    "body": ".getFogColor()",
    "description": "<Biome>.getFogColor()\nThis function returns fog color of the biome.\n"
  },
  "Method <Biome>.getId()": {
    "prefix": ".getId()",
    "body": ".getId()",
    "description": "<Biome>.getId()\nThis function returns the path id of the biome, e.g. 'plains'.\n"
  },
  "Method <Biome>.getSkyColor()": {
    "prefix": ".getSkyColor()",
    "body": ".getSkyColor()",
    "description": "<Biome>.getSkyColor()\nThis function returns sky color of the biome.\n"
  },
  "Method <Biome>.getTemperature()": {
    "prefix": ".getTemperature()",
    "body": ".getTemperature()",
    "description": "<Biome>.getTemperature()\nThis function returns temperature of the biome.\n"
  },
  "Method <Biome>.getWaterColor()": {
    "prefix": ".getWaterColor()",
    "body": ".getWaterColor()",
    "description": "<Biome>.getWaterColor()\nThis function returns Fog color of the biome.\n"
  },
  "Method <Biome>.getWaterFogColor()": {
    "prefix": ".getWaterFogColor()",
    "body": ".getWaterFogColor()",
    "description": "<Biome>.getWaterFogColor()\nThis function returns water fog color of the biome.\n"
  },
  "Method <Biome>.isCold(pos)": {
    "prefix": ".isCold($pos)",
    "body": ".isCold($pos)",
    "description": "<Biome>.isCold(pos)\nThis function calculates whether biome is cold at given position.\n- Parameter - Pos (`pos`): The position.\n"
  },
  "Method <Biome>.isCold(x, y, z)": {
    "prefix": ".isCold($x, $y, $z)",
    "body": ".isCold($x, $y, $z)",
    "description": "<Biome>.isCold(x, y, z)\nThis function calculates whether biome is cold at given position.\n- Parameter - Number (`x`): The x coordinate.\n- Parameter - Number (`y`): The y coordinate.\n- Parameter - Number (`z`): The z coordinate.\n"
  },
  "Method <Biome>.isHot(pos)": {
    "prefix": ".isHot($pos)",
    "body": ".isHot($pos)",
    "description": "<Biome>.isHot(pos)\nThis function calculates whether a biome is hot at given position.\n- Parameter - Pos (`pos`): The position.\n"
  },
  "Method <Biome>.isHot(x, y, z)": {
    "prefix": ".isHot($x, $y, $z)",
    "body": ".isHot($x, $y, $z)",
    "description": "<Biome>.isHot(x, y, z)\nThis function calculates whether a biome is hot at given position.\n- Parameter - Number (`x`): The x coordinate.\n- Parameter - Number (`y`): The y coordinate.\n- Parameter - Number (`z`): The z coordinate.\n"
  },
  "Block Class": {
    "prefix": "Block",
    "body": "Block",
    "description": "The Block class from Minecraft.\nThis class allows interactions with blocks in Minecraft.\n"
  },
  "Method <Block>.getBlastResistance()": {
    "prefix": ".getBlastResistance()",
    "body": ".getBlastResistance()",
    "description": "<Block>.getBlastResistance()\nThis gets the blast resistance of the Block.\n"
  },
  "Method <Block>.getBlockEntityNbt()": {
    "prefix": ".getBlockEntityNbt()",
    "body": ".getBlockEntityNbt()",
    "description": "<Block>.getBlockEntityNbt()\nThis gets the NBT of a block entity.\n"
  },
  "Method <Block>.getBlockProperties()": {
    "prefix": ".getBlockProperties()",
    "body": ".getBlockProperties()",
    "description": "<Block>.getBlockProperties()\nThis gets the properties of the Block\nYou can find a list of all block properties\n[here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Block_states).\n"
  },
  "Method <Block>.getDefaultState()": {
    "prefix": ".getDefaultState()",
    "body": ".getDefaultState()",
    "description": "<Block>.getDefaultState()\nThis gets the default state of the block, it will conserve any positions.\n"
  },
  "Method <Block>.getHardness()": {
    "prefix": ".getHardness()",
    "body": ".getHardness()",
    "description": "<Block>.getHardness()\nThis gets the hardness of the Block.\n"
  },
  "Method <Block>.getLuminance()": {
    "prefix": ".getLuminance()",
    "body": ".getLuminance()",
    "description": "<Block>.getLuminance()\nThis gets the luminance of the Block.\n"
  },
  "Method <Block>.getMapColour()": {
    "prefix": ".getMapColour()",
    "body": ".getMapColour()",
    "description": "<Block>.getMapColour()\nThis gets the map colour of the Block, can also be called with 'getMapColor'.\n"
  },
  "Method <Block>.getMaterial()": {
    "prefix": ".getMaterial()",
    "body": ".getMaterial()",
    "description": "<Block>.getMaterial()\nThis gets the material of the Block.\n"
  },
  "Method <Block>.getPos()": {
    "prefix": ".getPos()",
    "body": ".getPos()",
    "description": "<Block>.getPos()\nThis gets the position of the Block.\n"
  },
  "Method <Block>.getX()": {
    "prefix": ".getX()",
    "body": ".getX()",
    "description": "<Block>.getX()\nThis gets the X position of the Block.\n"
  },
  "Method <Block>.getY()": {
    "prefix": ".getY()",
    "body": ".getY()",
    "description": "<Block>.getY()\nThis gets the Y position of the Block.\n"
  },
  "Method <Block>.getZ()": {
    "prefix": ".getZ()",
    "body": ".getZ()",
    "description": "<Block>.getZ()\nThis gets the Z position of the Block.\n"
  },
  "Method <Block>.hasBlockPosition()": {
    "prefix": ".hasBlockPosition()",
    "body": ".hasBlockPosition()",
    "description": "<Block>.hasBlockPosition()\nThis checks if the Block has a position or not.\n"
  },
  "Method <Block>.isBlockEntity()": {
    "prefix": ".isBlockEntity()",
    "body": ".isBlockEntity()",
    "description": "<Block>.isBlockEntity()\nThis checks if the Block is a BlockEntity.\n"
  },
  "Method <Block>.isFluid()": {
    "prefix": ".isFluid()",
    "body": ".isFluid()",
    "description": "<Block>.isFluid()\nThis checks if the Block is a fluid.\n"
  },
  "Method <Block>.isFluidSource()": {
    "prefix": ".isFluidSource()",
    "body": ".isFluidSource()",
    "description": "<Block>.isFluidSource()\nThis checks if the Block is a fluid source.\n"
  },
  "Method <Block>.isReplaceable()": {
    "prefix": ".isReplaceable()",
    "body": ".isReplaceable()",
    "description": "<Block>.isReplaceable()\nThis checks if the Block is replaceable.\n"
  },
  "Method <Block>.isSideSolidFullSquare(side)": {
    "prefix": ".isSideSolidFullSquare($side)",
    "body": ".isSideSolidFullSquare($side)",
    "description": "<Block>.isSideSolidFullSquare(side)\nThis checks if the Block is solid on the full square.\n- Parameter - String (`side`): The side to check, for example: 'north', 'south', 'east', 'west', 'up', 'down'.\n"
  },
  "Method <Block>.isSolidBlock()": {
    "prefix": ".isSolidBlock()",
    "body": ".isSolidBlock()",
    "description": "<Block>.isSolidBlock()\nThis checks if the Block is a solid block.\n"
  },
  "Method <Block>.isSpawnable()": {
    "prefix": ".isSpawnable()",
    "body": ".isSpawnable()",
    "description": "<Block>.isSpawnable()\nThis checks if the Block is spawnable in the case of zombies.\n"
  },
  "Method <Block>.isSpawnable(entity)": {
    "prefix": ".isSpawnable($entity)",
    "body": ".isSpawnable($entity)",
    "description": "<Block>.isSpawnable(entity)\nThis checks if the Block allows spawning for given entity.\n- Parameter - Entity (`entity`): The entity to check.\n"
  },
  "Method <Block>.isTransparent()": {
    "prefix": ".isTransparent()",
    "body": ".isTransparent()",
    "description": "<Block>.isTransparent()\nThis checks if the Block is transparent.\n"
  },
  "Method <Block>.mirrorFrontBack()": {
    "prefix": ".mirrorFrontBack()",
    "body": ".mirrorFrontBack()",
    "description": "<Block>.mirrorFrontBack()\nThis mirrors the Block around the front and back.\n"
  },
  "Method <Block>.mirrorLeftRight()": {
    "prefix": ".mirrorLeftRight()",
    "body": ".mirrorLeftRight()",
    "description": "<Block>.mirrorLeftRight()\nThis mirrors the Block around the left and right.\n"
  },
  "Method <Block>.offset(offset)": {
    "prefix": ".offset($offset)",
    "body": ".offset($offset)",
    "description": "<Block>.offset(offset)\nThis gets a block with a given offset, this will throw if the block has no position.\n- Parameter - Pos (`offset`): The position offset to add to the block's current position.\n"
  },
  "Method <Block>.offset(direction, distance)": {
    "prefix": ".offset($direction, $distance)",
    "body": ".offset($direction, $distance)",
    "description": "<Block>.offset(direction, distance)\nThis gets a block with a given offset, this will throw if the block has no position.\n- Parameter - String (`direction`): The direction of the offset.\n- Parameter - Number (`distance`): The distance of the offset.\n"
  },
  "Method <Block>.rotateYClockwise()": {
    "prefix": ".rotateYClockwise()",
    "body": ".rotateYClockwise()",
    "description": "<Block>.rotateYClockwise()\nThis rotates the Block 90 degrees clockwise.\n"
  },
  "Method <Block>.rotateYCounterClockwise()": {
    "prefix": ".rotateYCounterClockwise()",
    "body": ".rotateYCounterClockwise()",
    "description": "<Block>.rotateYCounterClockwise()\nThis rotates the Block 90 degrees counter-clockwise.\n"
  },
  "Method <Block>.sideCoversSmallSquare(side)": {
    "prefix": ".sideCoversSmallSquare($side)",
    "body": ".sideCoversSmallSquare($side)",
    "description": "<Block>.sideCoversSmallSquare(side)\nThis checks if the Block covers a small square.\n- Parameter - String (`side`): The side to check, for example: 'north', 'south', 'east', 'west', 'up', 'down'.\n"
  },
  "Method <Block>.with(property, value)": {
    "prefix": ".with($property, $value)",
    "body": ".with($property, $value)",
    "description": "<Block>.with(property, value)\nThis gets modified block with a property value, conserving positions.\n- Parameter - String (`property`): Property name, such as 'facing', 'extended'.\n- Parameter - String (`value`): Value name, such as 'north', 'true'.\n"
  },
  "Static Method Block.of(material)": {
    "prefix": "Block.of(material)",
    "body": "Block.of($material)",
    "description": "Block.of(material)\nThis creates a Block from a material or string.\n- Parameter - Material (`material`): The material, item stack, block, or string to create the Block from.\n"
  },
  "Boolean Class": {
    "prefix": "Boolean",
    "body": "Boolean",
    "description": "The Boolean class.\nThis is the boolean type, representing either true or false.\nThis class cannot be instantiated, or extended.\n"
  },
  "BoxShape Class": {
    "prefix": "BoxShape",
    "body": "BoxShape",
    "description": "The BoxShape class from Minecraft.\nThis class allows you to create box shapes that can be rendered in the world.\n"
  },
  "Constructor new BoxShape(pos)": {
    "prefix": "new BoxShape($pos)",
    "body": "new BoxShape($pos)",
    "description": "new BoxShape(pos)\nCreates a new box shape, this is used to render boxes.\n- Parameter - Pos (`pos`): The position which will be used for the first and second corner of the box.\n"
  },
  "Constructor new BoxShape(pos1, pos2)": {
    "prefix": "new BoxShape($pos1, $pos2)",
    "body": "new BoxShape($pos1, $pos2)",
    "description": "new BoxShape(pos1, pos2)\nCreates a new box shape, this is used to render boxes.\n- Parameter - Pos (`pos1`): The position of the first corner of the box.\n- Parameter - Pos (`pos2`): The position of the second corner of the box.\n"
  },
  "Constructor new BoxShape(x, y, z)": {
    "prefix": "new BoxShape($x, $y, $z)",
    "body": "new BoxShape($x, $y, $z)",
    "description": "new BoxShape(x, y, z)\nCreates a new box shape, this is used to render boxes.\n- Parameter - Number (`x`): The x position which will be used for the first and second corner of the box.\n- Parameter - Number (`y`): The y position which will be used for the first and second corner of the box.\n- Parameter - Number (`z`): The z position which will be used for the first and second corner of the box.\n"
  },
  "Constructor new BoxShape(x1, y1, z1, x2, y2, z2)": {
    "prefix": "new BoxShape($x1, $y1, $z1, $x2, $y2, $z2)",
    "body": "new BoxShape($x1, $y1, $z1, $x2, $y2, $z2)",
    "description": "new BoxShape(x1, y1, z1, x2, y2, z2)\nCreates a new box shape, this is used to render boxes.\n- Parameter - Number (`x1`): The x position of the first corner of the box.\n- Parameter - Number (`y1`): The y position of the first corner of the box.\n- Parameter - Number (`z1`): The z position of the first corner of the box.\n- Parameter - Number (`x2`): The x position of the second corner of the box.\n- Parameter - Number (`y2`): The y position of the second corner of the box.\n- Parameter - Number (`z2`): The z position of the second corner of the box.\n"
  },
  "CentredShape Class": {
    "prefix": "CentredShape",
    "body": "CentredShape",
    "description": "The CentredShape class from Minecraft.\nThis class represents shapes that are positioned centrally with a width.\n"
  },
  "Method <CentredShape>.centrePositions()": {
    "prefix": ".centrePositions()",
    "body": ".centrePositions()",
    "description": "<CentredShape>.centrePositions()\nThis centres the positions of the shape.\n"
  },
  "Method <CentredShape>.getPos()": {
    "prefix": ".getPos()",
    "body": ".getPos()",
    "description": "<CentredShape>.getPos()\nThis gets the central position of the shape.\n"
  },
  "Method <CentredShape>.getWidth()": {
    "prefix": ".getWidth()",
    "body": ".getWidth()",
    "description": "<CentredShape>.getWidth()\nThis gets the width of the shape.\n"
  },
  "Method <CentredShape>.setPos(pos)": {
    "prefix": ".setPos($pos)",
    "body": ".setPos($pos)",
    "description": "<CentredShape>.setPos(pos)\nThis sets the central position of the shape.\n- Parameter - Pos (`pos`): The central position of the shape.\n"
  },
  "Method <CentredShape>.setWidth(width)": {
    "prefix": ".setWidth($width)",
    "body": ".setWidth($width)",
    "description": "<CentredShape>.setWidth(width)\nThis sets the width of the shape.\n- Parameter - Number (`width`): The width of the shape.\n"
  },
  "Collection Class": {
    "prefix": "Collection",
    "body": "Collection",
    "description": "The Collection class.\nThis class is used to represent a collection of objects,\nthis class is used internally as the parent of maps, lists, and sets.\nThis cannot be instantiated directly.\nAll collections inherit Iterable, and thus can be iterated over.\n"
  },
  "Constructor new Collection()": {
    "prefix": "new Collection()",
    "body": "new Collection()",
    "description": "new Collection()\nThis creates a collection, this cannot be called directly, only from child classes.\n"
  },
  "Method <Collection>.isEmpty()": {
    "prefix": ".isEmpty()",
    "body": ".isEmpty()",
    "description": "<Collection>.isEmpty()\nThis allows you to check if the collection is empty.\n"
  },
  "Method <Collection>.size()": {
    "prefix": ".size()",
    "body": ".size()",
    "description": "<Collection>.size()\nThis allows you to get the size of the collection.\n"
  },
  "CommandBuilder Class": {
    "prefix": "CommandBuilder",
    "body": "CommandBuilder",
    "description": "The CommandBuilder class from Minecraft.\nThis class allows you to build commands for Minecraft.\n"
  },
  "Method <CommandBuilder>.executes(function)": {
    "prefix": ".executes($function)",
    "body": ".executes($function)",
    "description": "<CommandBuilder>.executes(function)\nThis sets the function to be executed when the command is executed,\nthis should have the correct amount of parameters for the command.\n- Parameter - CommandBuilder (`function`): The function to execute.\n"
  },
  "Method <CommandBuilder>.then(childBuilder)": {
    "prefix": ".then($childBuilder)",
    "body": ".then($childBuilder)",
    "description": "<CommandBuilder>.then(childBuilder)\nThis adds a child CommandBuilder to your command builder.\n- Parameter - CommandBuilder (`childBuilder`): The child command builder to add.\n"
  },
  "Static Method CommandBuilder.argument(argumentName, argumentType)": {
    "prefix": "CommandBuilder.argument(argumentName, argumentType)",
    "body": "CommandBuilder.argument($argumentName, $argumentType)",
    "description": "CommandBuilder.argument(argumentName, argumentType)\nCreates an argument builder with a specific argument type, and a name\nto see all the different types refer to CommandBuilder.fromMap(...).\n- Parameter - String (`argumentName`): The name of the argument.\n- Parameter - String (`argumentType`): The type of the argument.\n"
  },
  "Static Method CommandBuilder.argument(argumentName, argumentType, suggestions)": {
    "prefix": "CommandBuilder.argument(argumentName, argumentType, suggestions)",
    "body": "CommandBuilder.argument($argumentName, $argumentType, $suggestions)",
    "description": "CommandBuilder.argument(argumentName, argumentType, suggestions)\nCreates an argument builder with a specific argument type, a name, and a default value\nto see all the different types refer to CommandBuilder.fromMap(...).\n- Parameter - String (`argumentName`): The name of the argument.\n- Parameter - String (`argumentType`): The type of the argument.\n- Parameter - List (`suggestions`): A list of strings for the suggestions for the argument.\n"
  },
  "Static Method CommandBuilder.fromMap(argumentMap)": {
    "prefix": "CommandBuilder.fromMap(argumentMap)",
    "body": "CommandBuilder.fromMap($argumentMap)",
    "description": "CommandBuilder.fromMap(argumentMap)\nCreates an argument builder from a map.\nThe map must contain a 'name' key as a String that is the name of the command,\nthe map then can contain 'subcommands' as a map which contains the subcommands,\nthe key of the subcommands is the name of the subcommand, and the value is a map,\nif the name is encased in '<' and '>' it will be treated as an argument, otherwise it will be treated as a literal.\nYou can chain arguments by leaving a space in the name like: 'literal <arg>'.\nIf the key has no name and is just an empty string the value will be used as the function\nwhich will be executed when the command is executed, the function should have the appropriate\nnumber of parameters, the number of parameters is determined by the number of arguments.\nArgument types are defined in the main map under the key 'arguments' with the value of a map\nthe keys of this map should be the names of your arguments used in your subcommands,\nthis should be a map and must have the key 'type' which should be a string that is the type of the argument.\nOptionally if the type is of 'integer' or 'double' you can also have the key 'min' and 'max' with numbers as the value,\nand if the type is of 'enum' you must have the key 'enum' with the enum class type as the value: 'enum': MyEnum.type.\nYou can also optionally have 'suggests' which has the value of a list of strings that are suggestions for the argument.\nYou can also optionally have 'suggester' which has the value of a function that will be called to get suggestions for the argument,\nthis function should have arbitrary number of parameters which will be the arguments that the user has entered so far.\nThe possible argument types are: 'PlayerName', 'Word' 'String', 'GreedyString', 'Double', 'Integer', 'Boolean', 'Enum',\n'ItemStack', 'Block', 'Particle', 'RecipeId', 'EntityId', 'EnchantmentId', 'Entity', 'Entities', 'BlockPos', 'Pos', 'Effect',\n'BiomeId'.\n- Parameter - Map (`argumentMap`): The map of arguments.\n"
  },
  "Static Method CommandBuilder.literal(argument)": {
    "prefix": "CommandBuilder.literal(argument)",
    "body": "CommandBuilder.literal($argument)",
    "description": "CommandBuilder.literal(argument)\nCreates a literal argument with just a string.\n- Parameter - String (`argument`): The literal argument.\n"
  },
  "Config Class": {
    "prefix": "Config",
    "body": "Config",
    "description": "The Config class from Minecraft.\nThis class allows you to create configs for your scripts.\n"
  },
  "Method <Config>.addListener(listener)": {
    "prefix": ".addListener($listener)",
    "body": ".addListener($listener)",
    "description": "<Config>.addListener(listener)\nAdds a listener to the config, the listener will be called when the config is changed\nThe listener must have one parameter, this is the new value that was set.\n- Parameter - Function (`listener`): The listener to add.\n"
  },
  "Method <Config>.getCategory()": {
    "prefix": ".getCategory()",
    "body": ".getCategory()",
    "description": "<Config>.getCategory()\nGets the category of the config.\n"
  },
  "Method <Config>.getDefaultValue()": {
    "prefix": ".getDefaultValue()",
    "body": ".getDefaultValue()",
    "description": "<Config>.getDefaultValue()\nGets the default value of the config.\n"
  },
  "Method <Config>.getDescription()": {
    "prefix": ".getDescription()",
    "body": ".getDescription()",
    "description": "<Config>.getDescription()\nGets the description of the config.\n"
  },
  "Method <Config>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Config>.getName()\nGets the name of the config.\n"
  },
  "Method <Config>.getOptionalInfo()": {
    "prefix": ".getOptionalInfo()",
    "body": ".getOptionalInfo()",
    "description": "<Config>.getOptionalInfo()\nGets the optional info of the config.\n"
  },
  "Method <Config>.getType()": {
    "prefix": ".getType()",
    "body": ".getType()",
    "description": "<Config>.getType()\nGets the type of the config.\n"
  },
  "Method <Config>.getValue()": {
    "prefix": ".getValue()",
    "body": ".getValue()",
    "description": "<Config>.getValue()\nGets the value of the config.\n"
  },
  "Method <Config>.resetToDefault()": {
    "prefix": ".resetToDefault()",
    "body": ".resetToDefault()",
    "description": "<Config>.resetToDefault()\nResets the config to the default value.\n"
  },
  "Method <Config>.setValue(value)": {
    "prefix": ".setValue($value)",
    "body": ".setValue($value)",
    "description": "<Config>.setValue(value)\nSets the value of the config, if the value is invalid it will not be changed\nIf you are modifying a list rule you must pass in a list to this method.\n- Parameter - Object (`value`): The new value of the config.\n"
  },
  "Method <Config>.toJson()": {
    "prefix": ".toJson()",
    "body": ".toJson()",
    "description": "<Config>.toJson()\nConverts the config into a json value, this will not keep the listeners.\n"
  },
  "Static Method Config.fromListOfMap(list)": {
    "prefix": "Config.fromListOfMap(list)",
    "body": "Config.fromListOfMap($list)",
    "description": "Config.fromListOfMap(list)\nCreates a config from a list of config maps.\n- Parameter - List (`list`): The list of config maps.\n"
  },
  "Static Method Config.fromMap(map)": {
    "prefix": "Config.fromMap(map)",
    "body": "Config.fromMap($map)",
    "description": "Config.fromMap(map)\nCreates a config from a map\nThe map must contain the following keys:\n'type' which is the type of the config which can be 'boolean', 'cycle', 'double', 'double_slider', 'integer', 'integer_slider', 'list', or 'string',\n'name' which is the name of the config\nAnd can optionally contain the following keys:\n'description' which is a description of the config,\n'optional_info' which is an optional info for the config,\n'default_value' which is the default value of the config,\n'category' which is the category of the config,\n'value' which is the current value of the config, \n'listener' which is a function that will be called when the config changes, this must have 1 parameter which is the rule that was changed,\n'max_length' which is the max length for the input of the config, this must be an integer > 0, default is 32\nAnd 'cycle' types must contain the following keys:\n'cycle_values' which is a list of values that the config can cycle through.\nAnd slider types must contain the following keys:\n'min' which is the minimum value of the slider,\n'max' which is the maximum value of the slider.\n- Parameter - Map (`map`): The map to create the config from.\n"
  },
  "ConfigHandler Class": {
    "prefix": "ConfigHandler",
    "body": "ConfigHandler",
    "description": "The ConfigHandler class from Minecraft.\nThis class allows you to easily read and write config files.\n"
  },
  "Constructor new ConfigHandler(name)": {
    "prefix": "new ConfigHandler($name)",
    "body": "new ConfigHandler($name)",
    "description": "new ConfigHandler(name)\nCreates a new ConfigHandler, this is used to read and save configs.\n- Parameter - String (`name`): The name of the config, this will also be the name of the config file.\n"
  },
  "Constructor new ConfigHandler(name, read)": {
    "prefix": "new ConfigHandler($name, $read)",
    "body": "new ConfigHandler($name, $read)",
    "description": "new ConfigHandler(name, read)\nCreates a new ConfigHandler, this is used to read and save configs.\n- Parameter - String (`name`): The name of the config, this will also be the name of the config file.\n- Parameter - Boolean (`read`): Whether or not to read the config on creation.\n"
  },
  "Method <ConfigHandler>.addConfig(config)": {
    "prefix": ".addConfig($config)",
    "body": ".addConfig($config)",
    "description": "<ConfigHandler>.addConfig(config)\nAdds a config to the handler.\n- Parameter - Config (`config`): The config to add.\n"
  },
  "Method <ConfigHandler>.addConfigs(configs)": {
    "prefix": ".addConfigs($configs)",
    "body": ".addConfigs($configs)",
    "description": "<ConfigHandler>.addConfigs(configs)\nAdds multiple configs to the handler, you can pass in a list of configs\nor a varargs of configs, this is for compatability with older scripts.\n- Parameter - Config (`configs...`): The configs to add.\n"
  },
  "Method <ConfigHandler>.createScreen()": {
    "prefix": ".createScreen()",
    "body": ".createScreen()",
    "description": "<ConfigHandler>.createScreen()\nCreates a new config screen containing all of the configs in the handler, in alphabetical order.\nThe screen name will be the default, the same as the name of the config handler.\n"
  },
  "Method <ConfigHandler>.createScreen(title)": {
    "prefix": ".createScreen($title)",
    "body": ".createScreen($title)",
    "description": "<ConfigHandler>.createScreen(title)\nCreates a new config screen containing all of the configs in the handler, in alphabetical order.\n- Parameter - Text (`title`): The title of the screen.\n"
  },
  "Method <ConfigHandler>.createScreen(title, alphabetical)": {
    "prefix": ".createScreen($title, $alphabetical)",
    "body": ".createScreen($title, $alphabetical)",
    "description": "<ConfigHandler>.createScreen(title, alphabetical)\nCreates a new config screen containing all of the configs in the handler.\n- Parameter - Text (`title`): The title of the screen.\n- Parameter - Boolean (`alphabetical`): Whether or not to sort the configs alphabetically.\n"
  },
  "Method <ConfigHandler>.getAllConfigs()": {
    "prefix": ".getAllConfigs()",
    "body": ".getAllConfigs()",
    "description": "<ConfigHandler>.getAllConfigs()\nGets all the configs in the handler.\n"
  },
  "Method <ConfigHandler>.getConfig(name)": {
    "prefix": ".getConfig($name)",
    "body": ".getConfig($name)",
    "description": "<ConfigHandler>.getConfig(name)\nGets a config from the handler.\n- Parameter - String (`name`): The name of the config.\n"
  },
  "Method <ConfigHandler>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<ConfigHandler>.getName()\nGets the name of the config.\n"
  },
  "Method <ConfigHandler>.read()": {
    "prefix": ".read()",
    "body": ".read()",
    "description": "<ConfigHandler>.read()\nReads the all the configs from the file\nIf configs are already in the handler, only the values\nwill be overwritten.\n"
  },
  "Method <ConfigHandler>.removeConfig(name)": {
    "prefix": ".removeConfig($name)",
    "body": ".removeConfig($name)",
    "description": "<ConfigHandler>.removeConfig(name)\nRemoves a config from the handler.\n- Parameter - String (`name`): The name of the config to remove.\n"
  },
  "Method <ConfigHandler>.resetAllToDefault()": {
    "prefix": ".resetAllToDefault()",
    "body": ".resetAllToDefault()",
    "description": "<ConfigHandler>.resetAllToDefault()\nResets all configs to their default values.\n"
  },
  "Method <ConfigHandler>.save()": {
    "prefix": ".save()",
    "body": ".save()",
    "description": "<ConfigHandler>.save()\nSaves the configs to the file.\n"
  },
  "Method <ConfigHandler>.setSaveOnClose(saveOnClose)": {
    "prefix": ".setSaveOnClose($saveOnClose)",
    "body": ".setSaveOnClose($saveOnClose)",
    "description": "<ConfigHandler>.setSaveOnClose(saveOnClose)\nSets whether or not the configs should be saved when the script ends, by default this is true.\n- Parameter - Boolean (`saveOnClose`): Whether or not the configs should be saved when the script ends.\n"
  },
  "Method <ConfigHandler>.setSavePath(savePath)": {
    "prefix": ".setSavePath($savePath)",
    "body": ".setSavePath($savePath)",
    "description": "<ConfigHandler>.setSavePath(savePath)\nSets the path to save the configs to, this shouldn't include the file name.\n- Parameter - File (`savePath`): The path to save the configs to.\n"
  },
  "Method <ConfigHandler>.willSaveOnClose()": {
    "prefix": ".willSaveOnClose()",
    "body": ".willSaveOnClose()",
    "description": "<ConfigHandler>.willSaveOnClose()\nGets whether or not the configs will be saved when the script ends.\n"
  },
  "CorneredShape Class": {
    "prefix": "CorneredShape",
    "body": "CorneredShape",
    "description": "The CorneredShape class from Minecraft.\nThis class represents all shapes that use 2 corners to dictate their position.\n"
  },
  "Method <CorneredShape>.centrePositions()": {
    "prefix": ".centrePositions()",
    "body": ".centrePositions()",
    "description": "<CorneredShape>.centrePositions()\nThis centres the positions of the shape.\n"
  },
  "Method <CorneredShape>.getPos1()": {
    "prefix": ".getPos1()",
    "body": ".getPos1()",
    "description": "<CorneredShape>.getPos1()\nThis gets the first position of the shape.\n"
  },
  "Method <CorneredShape>.getPos2()": {
    "prefix": ".getPos2()",
    "body": ".getPos2()",
    "description": "<CorneredShape>.getPos2()\nThis gets the second position of the shape.\n"
  },
  "Method <CorneredShape>.setPos1(pos1)": {
    "prefix": ".setPos1($pos1)",
    "body": ".setPos1($pos1)",
    "description": "<CorneredShape>.setPos1(pos1)\nThis sets the first position of the shape.\n- Parameter - Pos (`pos1`): The first position of the shape.\n"
  },
  "Method <CorneredShape>.setPos2(pos2)": {
    "prefix": ".setPos2($pos2)",
    "body": ".setPos2($pos2)",
    "description": "<CorneredShape>.setPos2(pos2)\nThis sets the second position of the shape.\n- Parameter - Pos (`pos2`): The second position of the shape.\n"
  },
  "Entity Class": {
    "prefix": "Entity",
    "body": "Entity",
    "description": "The Entity class from Minecraft.\nThis class is mostly used to get data about entities.\n"
  },
  "Method <Entity>.canSpawnAt(pos)": {
    "prefix": ".canSpawnAt($pos)",
    "body": ".canSpawnAt($pos)",
    "description": "<Entity>.canSpawnAt(pos)\nThis checks whether the entity can spawn at given position with regard to light and hitbox.\n- Parameter - Pos (`pos`): The position to check.\n"
  },
  "Method <Entity>.collidesWith(pos, block)": {
    "prefix": ".collidesWith($pos, $block)",
    "body": ".collidesWith($pos, $block)",
    "description": "<Entity>.collidesWith(pos, block)\nThis checks whether the entity collides with a block at a given position.\n- Parameter - Pos (`pos`): The position to check.\n- Parameter - Block (`block`): The block to check.\n"
  },
  "Method <Entity>.getAge()": {
    "prefix": ".getAge()",
    "body": ".getAge()",
    "description": "<Entity>.getAge()\nThis gets the age of the entity in ticks.\n"
  },
  "Method <Entity>.getBiome()": {
    "prefix": ".getBiome()",
    "body": ".getBiome()",
    "description": "<Entity>.getBiome()\nThis gets the biome of the entity.\n"
  },
  "Method <Entity>.getCustomName()": {
    "prefix": ".getCustomName()",
    "body": ".getCustomName()",
    "description": "<Entity>.getCustomName()\nThis gets the custom name of the entity if it has one.\n"
  },
  "Method <Entity>.getDimension()": {
    "prefix": ".getDimension()",
    "body": ".getDimension()",
    "description": "<Entity>.getDimension()\nThis gets the dimension of the entity.\n"
  },
  "Method <Entity>.getDistanceTo(otherEntity)": {
    "prefix": ".getDistanceTo($otherEntity)",
    "body": ".getDistanceTo($otherEntity)",
    "description": "<Entity>.getDistanceTo(otherEntity)\nThis gets the distance between the entity and the other entity.\n- Parameter - Entity (`otherEntity`): The other entity.\n"
  },
  "Method <Entity>.getEntityIdNumber()": {
    "prefix": ".getEntityIdNumber()",
    "body": ".getEntityIdNumber()",
    "description": "<Entity>.getEntityIdNumber()\nThis gets the entity id number of the entity.\n"
  },
  "Method <Entity>.getEntityUuid()": {
    "prefix": ".getEntityUuid()",
    "body": ".getEntityUuid()",
    "description": "<Entity>.getEntityUuid()\nThis gets the uuid of the entity.\n"
  },
  "Method <Entity>.getFullId()": {
    "prefix": ".getFullId()",
    "body": ".getFullId()",
    "description": "<Entity>.getFullId()\nThis gets the full id of the entity, this returns the full id, so for example\n'minecraft:cow' you can find all entityNames on\n[Joa's Entity Property Encyclopedia](https://joakimthorsen.github.io/MCPropertyEncyclopedia/entities.html).\n"
  },
  "Method <Entity>.getHitbox()": {
    "prefix": ".getHitbox()",
    "body": ".getHitbox()",
    "description": "<Entity>.getHitbox()\nThis gets the hitbox of the entity in a list containing the two corners of the hitbox, the minimum point and the maximum point.\n"
  },
  "Method <Entity>.getId()": {
    "prefix": ".getId()",
    "body": ".getId()",
    "description": "<Entity>.getId()\nThis gets the id of the entity, this returns the id, so for examples 'cow'.\n"
  },
  "Method <Entity>.getLookingAtBlock()": {
    "prefix": ".getLookingAtBlock()",
    "body": ".getLookingAtBlock()",
    "description": "<Entity>.getLookingAtBlock()\nThis gets the block that the entity is currently looking at\nwith a max range of 20 blocks, if there is no block then it will return air.\n"
  },
  "Method <Entity>.getLookingAtBlock(maxDistance)": {
    "prefix": ".getLookingAtBlock($maxDistance)",
    "body": ".getLookingAtBlock($maxDistance)",
    "description": "<Entity>.getLookingAtBlock(maxDistance)\nThis gets the block that the entity is currently looking at\nwith a specific max range, if there is no block then it will return air.\n- Parameter - Number (`maxDistance`): The max range to ray cast.\n"
  },
  "Method <Entity>.getLookingAtBlock(maxDistance, fluidType)": {
    "prefix": ".getLookingAtBlock($maxDistance, $fluidType)",
    "body": ".getLookingAtBlock($maxDistance, $fluidType)",
    "description": "<Entity>.getLookingAtBlock(maxDistance, fluidType)\nThis gets the block that the entity is currently looking at\nwith a specific max range, and optionally whether fluids should\nbe included, if there is no block then it will return air.\n- Parameter - Number (`maxDistance`): The max range to ray cast.\n- Parameter - String (`fluidType`): The types of fluids to include, either 'none', 'sources', or 'all'.\n"
  },
  "Method <Entity>.getLookingAtPos(maxDistance)": {
    "prefix": ".getLookingAtPos($maxDistance)",
    "body": ".getLookingAtPos($maxDistance)",
    "description": "<Entity>.getLookingAtPos(maxDistance)\nThis gets the position that the entity is currently looking at with a specific max range.\n- Parameter - Number (`maxDistance`): The max range to ray cast.\n"
  },
  "Method <Entity>.getNbt()": {
    "prefix": ".getNbt()",
    "body": ".getNbt()",
    "description": "<Entity>.getNbt()\nThis gets the nbt of the entity as a map.\n"
  },
  "Method <Entity>.getPitch()": {
    "prefix": ".getPitch()",
    "body": ".getPitch()",
    "description": "<Entity>.getPitch()\nThis gets the pitch of the entity (vertical head rotation).\n"
  },
  "Method <Entity>.getPos()": {
    "prefix": ".getPos()",
    "body": ".getPos()",
    "description": "<Entity>.getPos()\nThis gets the position of the entity.\n"
  },
  "Method <Entity>.getSquaredDistanceTo(otherEntity)": {
    "prefix": ".getSquaredDistanceTo($otherEntity)",
    "body": ".getSquaredDistanceTo($otherEntity)",
    "description": "<Entity>.getSquaredDistanceTo(otherEntity)\nThis gets the squared distance between the entity and the other entity.\n- Parameter - Entity (`otherEntity`): The other entity.\n"
  },
  "Method <Entity>.getTranslatedName()": {
    "prefix": ".getTranslatedName()",
    "body": ".getTranslatedName()",
    "description": "<Entity>.getTranslatedName()\nThis gets the translated name of the entity, for examples 'minecraft:pig' would return 'Pig' if your language is in english.\n"
  },
  "Method <Entity>.getVelocity()": {
    "prefix": ".getVelocity()",
    "body": ".getVelocity()",
    "description": "<Entity>.getVelocity()\nThis gets the velocity of the entity in a list in the form [x, y, z].\n"
  },
  "Method <Entity>.getWorld()": {
    "prefix": ".getWorld()",
    "body": ".getWorld()",
    "description": "<Entity>.getWorld()\nThis gets the world the entity is in.\n"
  },
  "Method <Entity>.getX()": {
    "prefix": ".getX()",
    "body": ".getX()",
    "description": "<Entity>.getX()\nThis gets the x position of the entity.\n"
  },
  "Method <Entity>.getY()": {
    "prefix": ".getY()",
    "body": ".getY()",
    "description": "<Entity>.getY()\nThis gets the y position of the entity.\n"
  },
  "Method <Entity>.getYaw()": {
    "prefix": ".getYaw()",
    "body": ".getYaw()",
    "description": "<Entity>.getYaw()\nThis gets the yaw of the entity (horizontal head rotation).\n"
  },
  "Method <Entity>.getZ()": {
    "prefix": ".getZ()",
    "body": ".getZ()",
    "description": "<Entity>.getZ()\nThis gets the z position of the entity.\n"
  },
  "Method <Entity>.isFalling()": {
    "prefix": ".isFalling()",
    "body": ".isFalling()",
    "description": "<Entity>.isFalling()\nReturns true if the entity is falling.\n"
  },
  "Method <Entity>.isGlowing()": {
    "prefix": ".isGlowing()",
    "body": ".isGlowing()",
    "description": "<Entity>.isGlowing()\nReturns true if the entity is glowing.\n"
  },
  "Method <Entity>.isInLava()": {
    "prefix": ".isInLava()",
    "body": ".isInLava()",
    "description": "<Entity>.isInLava()\nReturns true if the entity is in lava.\n"
  },
  "Method <Entity>.isOf(entityId)": {
    "prefix": ".isOf($entityId)",
    "body": ".isOf($entityId)",
    "description": "<Entity>.isOf(entityId)\nThis checks if the entity is of the given entity id.\n- Parameter - String (`entityId`): The entity id to check.\n"
  },
  "Method <Entity>.isOnFire()": {
    "prefix": ".isOnFire()",
    "body": ".isOnFire()",
    "description": "<Entity>.isOnFire()\nReturns true if the entity is on fire.\n"
  },
  "Method <Entity>.isOnGround()": {
    "prefix": ".isOnGround()",
    "body": ".isOnGround()",
    "description": "<Entity>.isOnGround()\nReturns true if the entity is on the ground.\n"
  },
  "Method <Entity>.isSneaking()": {
    "prefix": ".isSneaking()",
    "body": ".isSneaking()",
    "description": "<Entity>.isSneaking()\nReturns true if the player is sneaking.\n"
  },
  "Method <Entity>.isSprinting()": {
    "prefix": ".isSprinting()",
    "body": ".isSprinting()",
    "description": "<Entity>.isSprinting()\nReturns true if the player is sprinting.\n"
  },
  "Method <Entity>.isSubmergedInWater()": {
    "prefix": ".isSubmergedInWater()",
    "body": ".isSubmergedInWater()",
    "description": "<Entity>.isSubmergedInWater()\nReturns true if the entity is submerged in water.\n"
  },
  "Method <Entity>.isTouchingWater()": {
    "prefix": ".isTouchingWater()",
    "body": ".isTouchingWater()",
    "description": "<Entity>.isTouchingWater()\nReturns true if the entity is touching water.\n"
  },
  "Method <Entity>.isTouchingWaterOrRain()": {
    "prefix": ".isTouchingWaterOrRain()",
    "body": ".isTouchingWaterOrRain()",
    "description": "<Entity>.isTouchingWaterOrRain()\nReturns true if the entity is touching water or rain.\n"
  },
  "Method <Entity>.setGlowing(glowing)": {
    "prefix": ".setGlowing($glowing)",
    "body": ".setGlowing($glowing)",
    "description": "<Entity>.setGlowing(glowing)\nThis sets the entity to either start glowing or stop glowing on the client.\n- Parameter - Boolean (`glowing`): The glowing state.\n"
  },
  "Static Method Entity.of(entityId)": {
    "prefix": "Entity.of(entityId)",
    "body": "Entity.of($entityId)",
    "description": "Entity.of(entityId)\nThis converts an entityId into an entity instance.\nThis will throw an error if the id is not valid.\n- Parameter - String (`entityId`): The entityId to convert to an entity.\n"
  },
  "Enum Class": {
    "prefix": "Enum",
    "body": "Enum",
    "description": "The Enum class.\nThis class is the super class of all enums in Arucas.\nEnums cannot be instantiated or extended.\n"
  },
  "Method <Enum>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Enum>.getName()\nThis allows you to get the name of an enum value.\n"
  },
  "Method <Enum>.ordinal()": {
    "prefix": ".ordinal()",
    "body": ".ordinal()",
    "description": "<Enum>.ordinal()\nThis allows you to get the ordinal of the enum value.\n"
  },
  "Error Class": {
    "prefix": "Error",
    "body": "Error",
    "description": "The Error class.\nThis class is used for errors, and this is the only type that can be thrown.\nYou are able to extend this class to create your own error types.\n"
  },
  "Constructor new Error()": {
    "prefix": "new Error()",
    "body": "new Error()",
    "description": "new Error()\nThis creates a new Error value with no message.\n"
  },
  "Constructor new Error(details)": {
    "prefix": "new Error($details)",
    "body": "new Error($details)",
    "description": "new Error(details)\nThis creates a new Error value with the given details as a message.\n- Parameter - String (`details`): The details of the error.\n"
  },
  "Constructor new Error(details, value)": {
    "prefix": "new Error($details, $value)",
    "body": "new Error($details, $value)",
    "description": "new Error(details, value)\nThis creates a new Error value with the given details as a message and the given value.\n- Parameter - String (`details`): The details of the error.\n- Parameter - Object (`value`): The value that is related to the error.\n"
  },
  "Method <Error>.getDetails()": {
    "prefix": ".getDetails()",
    "body": ".getDetails()",
    "description": "<Error>.getDetails()\nThis returns the raw message of the error.\n"
  },
  "Method <Error>.getStackTraceString()": {
    "prefix": ".getStackTraceString()",
    "body": ".getStackTraceString()",
    "description": "<Error>.getStackTraceString()\nThis prints the stack trace of this error.\n"
  },
  "Method <Error>.getValue()": {
    "prefix": ".getValue()",
    "body": ".getValue()",
    "description": "<Error>.getValue()\nThis returns the value that is related to the error.\n"
  },
  "FakeBlock Class": {
    "prefix": "FakeBlock",
    "body": "FakeBlock",
    "description": "The FakeBlock class from Minecraft.\nThis class can be used to create fake blocks which can be rendered in the world.\n"
  },
  "Constructor new FakeBlock(block, pos)": {
    "prefix": "new FakeBlock($block, $pos)",
    "body": "new FakeBlock($block, $pos)",
    "description": "new FakeBlock(block, pos)\nCreates a fake block with the given block and position.\n- Parameter - Block (`block`): The block to use.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <FakeBlock>.getBlock()": {
    "prefix": ".getBlock()",
    "body": ".getBlock()",
    "description": "<FakeBlock>.getBlock()\nGets the current block type of the fake block.\n"
  },
  "Method <FakeBlock>.getDirection()": {
    "prefix": ".getDirection()",
    "body": ".getDirection()",
    "description": "<FakeBlock>.getDirection()\nGets the direction of the fake block.\n"
  },
  "Method <FakeBlock>.getPos()": {
    "prefix": ".getPos()",
    "body": ".getPos()",
    "description": "<FakeBlock>.getPos()\nGets the position of the fake block.\n"
  },
  "Method <FakeBlock>.setBlock(block)": {
    "prefix": ".setBlock($block)",
    "body": ".setBlock($block)",
    "description": "<FakeBlock>.setBlock(block)\nSets the block type to render of the fake block.\n- Parameter - Block (`block`): The block to render.\n"
  },
  "Method <FakeBlock>.setCull(cull)": {
    "prefix": ".setCull($cull)",
    "body": ".setCull($cull)",
    "description": "<FakeBlock>.setCull(cull)\nSets whether the fake block should be culled.\n- Parameter - Boolean (`cull`): Whether the fake block should be culled.\n"
  },
  "Method <FakeBlock>.setDirection(direction)": {
    "prefix": ".setDirection($direction)",
    "body": ".setDirection($direction)",
    "description": "<FakeBlock>.setDirection(direction)\nSets the direction of the fake block,\nthis may be null in which case the block will face the player.\n- Parameter - String (`direction`): The direction of the fake block.\n"
  },
  "Method <FakeBlock>.setPos(pos)": {
    "prefix": ".setPos($pos)",
    "body": ".setPos($pos)",
    "description": "<FakeBlock>.setPos(pos)\nSets the position of the fake block.\n- Parameter - Pos (`pos`): The position of the fake block.\n"
  },
  "Method <FakeBlock>.shouldCull()": {
    "prefix": ".shouldCull()",
    "body": ".shouldCull()",
    "description": "<FakeBlock>.shouldCull()\nGets whether the fake block should be culled.\n"
  },
  "FakeEntity Class": {
    "prefix": "FakeEntity",
    "body": "FakeEntity",
    "description": "The FakeEntity class from Minecraft.\nThis allows you to create a fake entity which can be rendered in the world.\n"
  },
  "Constructor new FakeEntity(entity, world)": {
    "prefix": "new FakeEntity($entity, $world)",
    "body": "new FakeEntity($entity, $world)",
    "description": "new FakeEntity(entity, world)\nCreates a new fake entity.\n- Parameter - Entity (`entity`): The entity that you want to create into a fake entity.\n- Parameter - World (`world`): The world that the entity is being rendered in.\n"
  },
  "Method <FakeEntity>.despawn()": {
    "prefix": ".despawn()",
    "body": ".despawn()",
    "description": "<FakeEntity>.despawn()\nDespawns the entity (makes it not render in the world).\n"
  },
  "Method <FakeEntity>.getBodyYaw()": {
    "prefix": ".getBodyYaw()",
    "body": ".getBodyYaw()",
    "description": "<FakeEntity>.getBodyYaw()\nGets the body yaw of the entity.\n"
  },
  "Method <FakeEntity>.getPitch()": {
    "prefix": ".getPitch()",
    "body": ".getPitch()",
    "description": "<FakeEntity>.getPitch()\nGets the pitch of the entity.\n"
  },
  "Method <FakeEntity>.getPos()": {
    "prefix": ".getPos()",
    "body": ".getPos()",
    "description": "<FakeEntity>.getPos()\nGets the position of the entity.\n"
  },
  "Method <FakeEntity>.getWorld()": {
    "prefix": ".getWorld()",
    "body": ".getWorld()",
    "description": "<FakeEntity>.getWorld()\nGets the world that the entity is being rendered in.\n"
  },
  "Method <FakeEntity>.getYaw()": {
    "prefix": ".getYaw()",
    "body": ".getYaw()",
    "description": "<FakeEntity>.getYaw()\nGets the yaw of the entity.\n"
  },
  "Method <FakeEntity>.setBodyYaw(bodyYaw)": {
    "prefix": ".setBodyYaw($bodyYaw)",
    "body": ".setBodyYaw($bodyYaw)",
    "description": "<FakeEntity>.setBodyYaw(bodyYaw)\nSets the body yaw of the entity with no interpolation.\n- Parameter - Number (`bodyYaw`): The new body yaw of the entity.\n"
  },
  "Method <FakeEntity>.setBodyYaw(bodyYaw, interpolationSteps)": {
    "prefix": ".setBodyYaw($bodyYaw, $interpolationSteps)",
    "body": ".setBodyYaw($bodyYaw, $interpolationSteps)",
    "description": "<FakeEntity>.setBodyYaw(bodyYaw, interpolationSteps)\nSets the body yaw of the entity.\n- Parameter - Number (`bodyYaw`): The new body yaw of the entity.\n- Parameter - Number (`interpolationSteps`): The number of interpolation steps to take.\n"
  },
  "Method <FakeEntity>.setPitch(pitch)": {
    "prefix": ".setPitch($pitch)",
    "body": ".setPitch($pitch)",
    "description": "<FakeEntity>.setPitch(pitch)\nSets the pitch of the entity with no interpolation.\n- Parameter - Number (`pitch`): The new pitch of the entity.\n"
  },
  "Method <FakeEntity>.setPitch(pitch, interpolationSteps)": {
    "prefix": ".setPitch($pitch, $interpolationSteps)",
    "body": ".setPitch($pitch, $interpolationSteps)",
    "description": "<FakeEntity>.setPitch(pitch, interpolationSteps)\nSets the pitch of the entity.\n- Parameter - Number (`pitch`): The new pitch of the entity.\n- Parameter - Number (`interpolationSteps`): The number of interpolation steps to take.\n"
  },
  "Method <FakeEntity>.setPos(pos)": {
    "prefix": ".setPos($pos)",
    "body": ".setPos($pos)",
    "description": "<FakeEntity>.setPos(pos)\nSets the position of the entity with no interpolation.\n- Parameter - Pos (`pos`): The new position of the entity.\n"
  },
  "Method <FakeEntity>.setPos(pos, interpolationSteps)": {
    "prefix": ".setPos($pos, $interpolationSteps)",
    "body": ".setPos($pos, $interpolationSteps)",
    "description": "<FakeEntity>.setPos(pos, interpolationSteps)\nSets the position of the entity.\n- Parameter - Pos (`pos`): The new position of the entity.\n- Parameter - Number (`interpolationSteps`): The number of interpolation steps to take.\n"
  },
  "Method <FakeEntity>.setWorld(world)": {
    "prefix": ".setWorld($world)",
    "body": ".setWorld($world)",
    "description": "<FakeEntity>.setWorld(world)\nSets the world that the entity is being rendered in.\n- Parameter - World (`world`): The world that the entity is being rendered in.\n"
  },
  "Method <FakeEntity>.setYaw(yaw)": {
    "prefix": ".setYaw($yaw)",
    "body": ".setYaw($yaw)",
    "description": "<FakeEntity>.setYaw(yaw)\nSets the yaw of the entity with no interpolation.\n- Parameter - Number (`yaw`): The new yaw of the entity.\n"
  },
  "Method <FakeEntity>.setYaw(yaw, interpolationSteps)": {
    "prefix": ".setYaw($yaw, $interpolationSteps)",
    "body": ".setYaw($yaw, $interpolationSteps)",
    "description": "<FakeEntity>.setYaw(yaw, interpolationSteps)\nSets the yaw of the entity.\n- Parameter - Number (`yaw`): The new yaw of the entity.\n- Parameter - Number (`interpolationSteps`): The number of interpolation steps to take.\n"
  },
  "Method <FakeEntity>.spawn()": {
    "prefix": ".spawn()",
    "body": ".spawn()",
    "description": "<FakeEntity>.spawn()\nSpawns the entity (makes it render in the world).\n"
  },
  "Method <FakeEntity>.updatePosAndRotation(pos, yaw, pitch)": {
    "prefix": ".updatePosAndRotation($pos, $yaw, $pitch)",
    "body": ".updatePosAndRotation($pos, $yaw, $pitch)",
    "description": "<FakeEntity>.updatePosAndRotation(pos, yaw, pitch)\nUpdates the position and rotation of the entity with no interpolation.\n- Parameter - Pos (`pos`): The new position of the entity.\n- Parameter - Number (`yaw`): The new yaw of the entity.\n- Parameter - Number (`pitch`): The new pitch of the entity.\n"
  },
  "Method <FakeEntity>.updatePosAndRotation(pos, yaw, pitch, interpolationSteps)": {
    "prefix": ".updatePosAndRotation($pos, $yaw, $pitch, $interpolationSteps)",
    "body": ".updatePosAndRotation($pos, $yaw, $pitch, $interpolationSteps)",
    "description": "<FakeEntity>.updatePosAndRotation(pos, yaw, pitch, interpolationSteps)\nUpdates the position and rotation of the entity.\n- Parameter - Pos (`pos`): The new position of the entity.\n- Parameter - Number (`yaw`): The new yaw of the entity.\n- Parameter - Number (`pitch`): The new pitch of the entity.\n- Parameter - Number (`interpolationSteps`): The number of interpolation steps to take.\n"
  },
  "FakeScreen Class": {
    "prefix": "FakeScreen",
    "body": "FakeScreen",
    "description": "The FakeScreen class from Minecraft.\nThis class extends Screen and so inherits all of their methods too,\nthis class is used to create client side inventory screens.\n"
  },
  "Constructor new FakeScreen(name, rows)": {
    "prefix": "new FakeScreen($name, $rows)",
    "body": "new FakeScreen($name, $rows)",
    "description": "new FakeScreen(name, rows)\nCreates a FakeScreen instance with given name and given amount of rows,\nthis will throw an error if the rows are not between 1 and 6.\n- Parameter - String (`name`): The name of the screen.\n- Parameter - Number (`rows`): The number of rows between 1 - 6.\n"
  },
  "Method <FakeScreen>.getStackForSlot(slotNum)": {
    "prefix": ".getStackForSlot($slotNum)",
    "body": ".getStackForSlot($slotNum)",
    "description": "<FakeScreen>.getStackForSlot(slotNum)\nGets the stack for the given slot, if the slot is out of bounds it returns null.\n- Parameter - Number (`slotNum`): The slot number.\n"
  },
  "Method <FakeScreen>.onClick(function)": {
    "prefix": ".onClick($function)",
    "body": ".onClick($function)",
    "description": "<FakeScreen>.onClick(function)\nThis sets the callback for when a slot is clicked in the inventory.\nThe callback must have 3 parameters, the first is the item stack that was clicked,\nthen second is the slot number, third is the action as a string, fourth is the\nbutton string: right, left, middle.\n- Parameter - Function (`function`): The callback function.\n"
  },
  "Method <FakeScreen>.setStackForSlot(slotNum, stack)": {
    "prefix": ".setStackForSlot($slotNum, $stack)",
    "body": ".setStackForSlot($slotNum, $stack)",
    "description": "<FakeScreen>.setStackForSlot(slotNum, stack)\nSets the stack for the given slot, if the slot is out of bounds it won't be set.\n- Parameter - Number (`slotNum`): The slot number.\n- Parameter - ItemStack (`stack`): The stack to set.\n"
  },
  "File Class": {
    "prefix": "File",
    "body": "File",
    "description": "The File class.\nThis class allows you to read and write files.\n"
  },
  "Constructor new File(path)": {
    "prefix": "new File($path)",
    "body": "new File($path)",
    "description": "new File(path)\nThis creates a new File object with set path.\n- Parameter - String (`path`): The path of the file.\n"
  },
  "Method <File>.createDirectory()": {
    "prefix": ".createDirectory()",
    "body": ".createDirectory()",
    "description": "<File>.createDirectory()\nThis creates all parent directories of the file if they don't already exist.\n"
  },
  "Method <File>.delete()": {
    "prefix": ".delete()",
    "body": ".delete()",
    "description": "<File>.delete()\nThis deletes the file.\n"
  },
  "Method <File>.exists()": {
    "prefix": ".exists()",
    "body": ".exists()",
    "description": "<File>.exists()\nThis returns if the file exists.\n"
  },
  "Method <File>.getAbsolutePath()": {
    "prefix": ".getAbsolutePath()",
    "body": ".getAbsolutePath()",
    "description": "<File>.getAbsolutePath()\nThis returns the absolute path of the file.\n"
  },
  "Method <File>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<File>.getName()\nThis returns the name of the file.\n"
  },
  "Method <File>.getPath()": {
    "prefix": ".getPath()",
    "body": ".getPath()",
    "description": "<File>.getPath()\nThis returns the path of the file.\n"
  },
  "Method <File>.getSubFiles()": {
    "prefix": ".getSubFiles()",
    "body": ".getSubFiles()",
    "description": "<File>.getSubFiles()\nThis returns a list of all the sub files in the directory.\n"
  },
  "Method <File>.open()": {
    "prefix": ".open()",
    "body": ".open()",
    "description": "<File>.open()\nThis opens the file (as in opens it on your os).\n"
  },
  "Method <File>.read()": {
    "prefix": ".read()",
    "body": ".read()",
    "description": "<File>.read()\nThis reads the file and returns the contents as a string.\n"
  },
  "Method <File>.resolve(filePath)": {
    "prefix": ".resolve($filePath)",
    "body": ".resolve($filePath)",
    "description": "<File>.resolve(filePath)\nThis gets a resolves file object from the current one.\n- Parameter - String (`filePath`): The relative file path.\n"
  },
  "Method <File>.write(string)": {
    "prefix": ".write($string)",
    "body": ".write($string)",
    "description": "<File>.write(string)\nThis writes a string to a file.\n- Parameter - String (`string`): The string to write to the file.\n"
  },
  "Static Method File.getDirectory()": {
    "prefix": "File.getDirectory()",
    "body": "File.getDirectory()",
    "description": "File.getDirectory()\nThis returns the file of user directory.\n"
  },
  "Function Class": {
    "prefix": "Function",
    "body": "Function",
    "description": "The Function class.\nThis class is used for functions, and this is the only type that can be called.\nYou are able to extend this class and implement an 'invoke' method to create\nyour own function types, this class cannot be instantiated directly.\n"
  },
  "Constructor new Function()": {
    "prefix": "new Function()",
    "body": "new Function()",
    "description": "new Function()\nThis creates a function, this cannot be called directly, only from child classes.\n"
  },
  "Future Class": {
    "prefix": "Future",
    "body": "Future",
    "description": "The Future class.\nThis class is used to represent values that are in the future.\nMore precisely values that are being evaluated on another thread,\nthis allows you to access those values once they've been processed.\n"
  },
  "Method <Future>.await()": {
    "prefix": ".await()",
    "body": ".await()",
    "description": "<Future>.await()\nThis blocks the current thread until the future has\nbeen completed and then returns the value of the future.\n"
  },
  "Method <Future>.isComplete()": {
    "prefix": ".isComplete()",
    "body": ".isComplete()",
    "description": "<Future>.isComplete()\nThis returns whether the future has been completed.\n"
  },
  "Static Method Future.completed(value)": {
    "prefix": "Future.completed(value)",
    "body": "Future.completed($value)",
    "description": "Future.completed(value)\nThis returns a future that with a complete value.\n- Parameter - Object (`value`): The value to complete the future with.\n"
  },
  "GameEvent Class": {
    "prefix": "GameEvent",
    "body": "GameEvent",
    "description": "The GameEvent class from Minecraft.\nThis class allows you to register listeners for game events in Minecraft.\n"
  },
  "Constructor new GameEvent(eventName, onEvent)": {
    "prefix": "new GameEvent($eventName, $onEvent)",
    "body": "new GameEvent($eventName, $onEvent)",
    "description": "new GameEvent(eventName, onEvent)\nThis creates a new GameEvent, that is not cancellable.\n- Parameter - String (`eventName`): The name of the event, you can find these on the GameEvents page.\n- Parameter - Function (`onEvent`): The function to run when the event is called, some events may have parameters.\n"
  },
  "Constructor new GameEvent(eventName, onEvent, cancellable)": {
    "prefix": "new GameEvent($eventName, $onEvent, $cancellable)",
    "body": "new GameEvent($eventName, $onEvent, $cancellable)",
    "description": "new GameEvent(eventName, onEvent, cancellable)\nThis creates a new GameEvent.\n- Parameter - String (`eventName`): The name of the event, you can find these on the GameEvents page.\n- Parameter - Function (`onEvent`): The function to run when the event is called, some events may have parameters.\n- Parameter - Boolean (`cancellable`): Whether or not the event is cancellable, if it is then it will run on the main thread.\n"
  },
  "Method <GameEvent>.isRegistered()": {
    "prefix": ".isRegistered()",
    "body": ".isRegistered()",
    "description": "<GameEvent>.isRegistered()\nThis returns whether or not the event is registered.\n"
  },
  "Method <GameEvent>.register()": {
    "prefix": ".register()",
    "body": ".register()",
    "description": "<GameEvent>.register()\nThis registers the event.\n"
  },
  "Method <GameEvent>.unregister()": {
    "prefix": ".unregister()",
    "body": ".unregister()",
    "description": "<GameEvent>.unregister()\nThis unregisters the event.\n"
  },
  "Static Method GameEvent.cancel()": {
    "prefix": "GameEvent.cancel()",
    "body": "GameEvent.cancel()",
    "description": "GameEvent.cancel()\nIf called on a cancellable event, this will stop execution and cancel the event,\nif called on a non-cancellable event, or not on an event, this will throw an error.\n"
  },
  "Static Method GameEvent.future()": {
    "prefix": "GameEvent.future()",
    "body": "GameEvent.future()",
    "description": "GameEvent.future()\nThis returns a future that allows you to wait for an event to occur.\n"
  },
  "Static Method GameEvent.unregisterAll()": {
    "prefix": "GameEvent.unregisterAll()",
    "body": "GameEvent.unregisterAll()",
    "description": "GameEvent.unregisterAll()\nThis unregisters all events registered by this script.\n"
  },
  "ItemEntity Class": {
    "prefix": "ItemEntity",
    "body": "ItemEntity",
    "description": "The ItemEntity class from Minecraft.\nThis class extends Entity and so inherits all of their methods too,\nItemEntities are entities that are dropped items.\n"
  },
  "Method <ItemEntity>.getCustomName()": {
    "prefix": ".getCustomName()",
    "body": ".getCustomName()",
    "description": "<ItemEntity>.getCustomName()\nThis method returns the custom name of the ItemEntity.\n"
  },
  "Method <ItemEntity>.getItemAge()": {
    "prefix": ".getItemAge()",
    "body": ".getItemAge()",
    "description": "<ItemEntity>.getItemAge()\nThis method returns the age of the ItemEntity\nthis is increased every tick and the item entity despawns after 6000 ticks.\n"
  },
  "Method <ItemEntity>.getItemStack()": {
    "prefix": ".getItemStack()",
    "body": ".getItemStack()",
    "description": "<ItemEntity>.getItemStack()\nThis method returns the ItemStack that is held in the ItemEntity.\n"
  },
  "Method <ItemEntity>.getThrower()": {
    "prefix": ".getThrower()",
    "body": ".getThrower()",
    "description": "<ItemEntity>.getThrower()\nThis method returns the player that threw the ItemEntity, null if not thrown by a player or player not found.\n"
  },
  "ItemStack Class": {
    "prefix": "ItemStack",
    "body": "ItemStack",
    "description": "The ItemStack class from Minecraft.\nThis class represents an item stack. It can be used to create new item stacks, or to modify existing ones.\n"
  },
  "Method <ItemStack>.asEntity()": {
    "prefix": ".asEntity()",
    "body": ".asEntity()",
    "description": "<ItemStack>.asEntity()\nThis creates an item entity with the item.\n"
  },
  "Method <ItemStack>.getCount()": {
    "prefix": ".getCount()",
    "body": ".getCount()",
    "description": "<ItemStack>.getCount()\nThis gets the count of the ItemStack, the amount of items in the stack.\n"
  },
  "Method <ItemStack>.getCustomName()": {
    "prefix": ".getCustomName()",
    "body": ".getCustomName()",
    "description": "<ItemStack>.getCustomName()\nThis gets the custom name of the ItemStack.\n"
  },
  "Method <ItemStack>.getDurability()": {
    "prefix": ".getDurability()",
    "body": ".getDurability()",
    "description": "<ItemStack>.getDurability()\nThis gets the durability of the item.\n"
  },
  "Method <ItemStack>.getEnchantments()": {
    "prefix": ".getEnchantments()",
    "body": ".getEnchantments()",
    "description": "<ItemStack>.getEnchantments()\nThis gets the enchantments of the item, in a map containing the\nid of the enchantment as the key and the level of the enchantment as the value.\n"
  },
  "Method <ItemStack>.getMaterial()": {
    "prefix": ".getMaterial()",
    "body": ".getMaterial()",
    "description": "<ItemStack>.getMaterial()\nThis gets the material of the ItemStack.\n"
  },
  "Method <ItemStack>.getMaxCount()": {
    "prefix": ".getMaxCount()",
    "body": ".getMaxCount()",
    "description": "<ItemStack>.getMaxCount()\nThis gets the max stack size of the ItemStack.\n"
  },
  "Method <ItemStack>.getMaxDurability()": {
    "prefix": ".getMaxDurability()",
    "body": ".getMaxDurability()",
    "description": "<ItemStack>.getMaxDurability()\nThis gets the max durability of the item.\n"
  },
  "Method <ItemStack>.getMiningSpeedMultiplier(block)": {
    "prefix": ".getMiningSpeedMultiplier($block)",
    "body": ".getMiningSpeedMultiplier($block)",
    "description": "<ItemStack>.getMiningSpeedMultiplier(block)\nThis gets the mining speed multiplier of the ItemStack for the given Block,\nfor example a diamond pickaxe on stone would have a higher multiplier than air on stone.\n- Parameter - Block (`block`): The Block to get the mining speed multiplier for.\n"
  },
  "Method <ItemStack>.getNbt()": {
    "prefix": ".getNbt()",
    "body": ".getNbt()",
    "description": "<ItemStack>.getNbt()\nThis gets the NBT data of the ItemStack as a Map.\n"
  },
  "Method <ItemStack>.getNbtAsString()": {
    "prefix": ".getNbtAsString()",
    "body": ".getNbtAsString()",
    "description": "<ItemStack>.getNbtAsString()\nThis gets the NBT data of the ItemStack as a String.\n"
  },
  "Method <ItemStack>.getTranslatedName()": {
    "prefix": ".getTranslatedName()",
    "body": ".getTranslatedName()",
    "description": "<ItemStack>.getTranslatedName()\nThis gets the translated name of the ItemStack, for example\n'diamond_sword' would return 'Diamond Sword' if your language is English.\n"
  },
  "Method <ItemStack>.isBlockItem()": {
    "prefix": ".isBlockItem()",
    "body": ".isBlockItem()",
    "description": "<ItemStack>.isBlockItem()\nThis checks if the ItemStack can be placed as a block.\n"
  },
  "Method <ItemStack>.isNbtEqual(itemStack)": {
    "prefix": ".isNbtEqual($itemStack)",
    "body": ".isNbtEqual($itemStack)",
    "description": "<ItemStack>.isNbtEqual(itemStack)\nThis checks if the ItemStack has the same NBT data as the other given ItemStack.\n- Parameter - ItemStack (`itemStack`): The other ItemStack to compare to.\n"
  },
  "Method <ItemStack>.isStackable()": {
    "prefix": ".isStackable()",
    "body": ".isStackable()",
    "description": "<ItemStack>.isStackable()\nThis checks if the ItemStack is stackable.\n"
  },
  "Method <ItemStack>.setCustomName(customName)": {
    "prefix": ".setCustomName($customName)",
    "body": ".setCustomName($customName)",
    "description": "<ItemStack>.setCustomName(customName)\nThis sets the custom name of the ItemStack.\n- Parameter - Text (`customName`): The custom name of the ItemStack, this can be text or string.\n"
  },
  "Method <ItemStack>.setItemLore(lore)": {
    "prefix": ".setItemLore($lore)",
    "body": ".setItemLore($lore)",
    "description": "<ItemStack>.setItemLore(lore)\nThis sets the lore of the ItemStack.\n- Parameter - List (`lore`): The lore of the ItemStack as a list of Text.\n"
  },
  "Method <ItemStack>.setNbt(nbtMap)": {
    "prefix": ".setNbt($nbtMap)",
    "body": ".setNbt($nbtMap)",
    "description": "<ItemStack>.setNbt(nbtMap)\nThis sets the NBT data of the ItemStack.\n- Parameter - Map (`nbtMap`): The NBT data of the ItemStack as a map.\n"
  },
  "Method <ItemStack>.setNbtFromString(nbtString)": {
    "prefix": ".setNbtFromString($nbtString)",
    "body": ".setNbtFromString($nbtString)",
    "description": "<ItemStack>.setNbtFromString(nbtString)\nThis sets the NBT data of the ItemStack from an NBT string.\n- Parameter - String (`nbtString`): The NBT data of the ItemStack as a string.\n"
  },
  "Method <ItemStack>.setStackSize(stackSize)": {
    "prefix": ".setStackSize($stackSize)",
    "body": ".setStackSize($stackSize)",
    "description": "<ItemStack>.setStackSize(stackSize)\nThis sets the stack size of the ItemStack.\n- Parameter - Number (`stackSize`): The stack size of the ItemStack.\n"
  },
  "Static Method ItemStack.of(material)": {
    "prefix": "ItemStack.of(material)",
    "body": "ItemStack.of($material)",
    "description": "ItemStack.of(material)\nThis creates an ItemStack from a material or a string.\n- Parameter - Material (`material`): The material, item stack, block, or string to create the ItemStack from.\n"
  },
  "Static Method ItemStack.parse(nbtString)": {
    "prefix": "ItemStack.parse(nbtString)",
    "body": "ItemStack.parse($nbtString)",
    "description": "ItemStack.parse(nbtString)\nThis creates an ItemStack from a NBT string, this can be in the form of a map\nor an ItemStack NBT, or like the item stack command format.\n- Parameter - String (`nbtString`): The NBT string to create the ItemStack from.\n"
  },
  "Iterable Class": {
    "prefix": "Iterable",
    "body": "Iterable",
    "description": "The Iterable class.\nThis class represents an object that can be iterated over.\nThis class is used internally to denote whether an object can be\niterated over inside a foreach loop.\n"
  },
  "Constructor new Iterable()": {
    "prefix": "new Iterable()",
    "body": "new Iterable()",
    "description": "new Iterable()\nThis creates an iterable, this cannot be called directly, only from child classes.\n"
  },
  "Method <Iterable>.all(predicate)": {
    "prefix": ".all($predicate)",
    "body": ".all($predicate)",
    "description": "<Iterable>.all(predicate)\nThis checks whether all the elements in the iterable meet a condition.\n- Parameter - Function (`predicate`): The predicate to check if the elements meet the conditions, must return a boolean.\n"
  },
  "Method <Iterable>.first(predicate)": {
    "prefix": ".first($predicate)",
    "body": ".first($predicate)",
    "description": "<Iterable>.first(predicate)\nThis finds the first element in the iterable that meets a condition.\nIf no element is found then an error will be thrown.\n- Parameter - Function (`predicate`): The predicate to check if the element meets the conditions, must return a boolean.\n"
  },
  "Method <Iterable>.forEach(consumer)": {
    "prefix": ".forEach($consumer)",
    "body": ".forEach($consumer)",
    "description": "<Iterable>.forEach(consumer)\nThis allows you to iterate over all the elements in the iterable with a lambda.\n- Parameter - Function (`consumer`): The consumer that accepts one element at a time.\n"
  },
  "Method <Iterable>.has(predicate)": {
    "prefix": ".has($predicate)",
    "body": ".has($predicate)",
    "description": "<Iterable>.has(predicate)\nChecks whether the iterable has a given elements that meets a given condition.\n- Parameter - Function (`predicate`): The predicate to check if the element meets the conditions, must return a boolean.\n"
  },
  "Method <Iterable>.iterator()": {
    "prefix": ".iterator()",
    "body": ".iterator()",
    "description": "<Iterable>.iterator()\nThis gets the generated iterator.\n"
  },
  "Iterator Class": {
    "prefix": "Iterator",
    "body": "Iterator",
    "description": "The Iterator class.\nThis class represents an object that iterates.\nThis is what is used internally to iterate in a\nforeach loop and you can create your own iterators\nto use be able to use them inside a foreach.\n"
  },
  "Constructor new Iterator()": {
    "prefix": "new Iterator()",
    "body": "new Iterator()",
    "description": "new Iterator()\nThis creates an iterator, this cannot be called directly, only from child classes.\n"
  },
  "Method <Iterator>.hasNext()": {
    "prefix": ".hasNext()",
    "body": ".hasNext()",
    "description": "<Iterator>.hasNext()\nChecks whether the iterator has a next item to iterate.\n"
  },
  "Method <Iterator>.next()": {
    "prefix": ".next()",
    "body": ".next()",
    "description": "<Iterator>.next()\nGets the next item in the iterator, may throw if there is no next item.\n"
  },
  "Java Class": {
    "prefix": "Java",
    "body": "Java",
    "description": "The Java class from util.Internal.\nThis class wraps Java values allowing for interactions between Java and Arucas.\nThis class cannot be instantiated or extended but you can create Java values by\nusing the static method 'Java.valueOf()' to convert Arucas to Java.\n"
  },
  "Method <Java>.callMethod(methodName, parameters)": {
    "prefix": ".callMethod($methodName, $parameters)",
    "body": ".callMethod($methodName, $parameters)",
    "description": "<Java>.callMethod(methodName, parameters)\nThis calls the specified method with the specified parameters, calling the method\nwith this function has no benefits unless you are calling a function that also is\nnative to Arucas. For example `object.copy()` will use the Arucas 'copy' function.\nBut this is extremely rare so almost all of the time you should all the method normally.\n- Parameter - String (`methodName`): The name of the method.\n- Parameter - Object (`parameters...`): The parameters to call the method with.\n"
  },
  "Method <Java>.getField(fieldName)": {
    "prefix": ".getField($fieldName)",
    "body": ".getField($fieldName)",
    "description": "<Java>.getField(fieldName)\nThis returns the Java wrapped value of the specified field.\nThere is no reason for you to be using this method, it will be removed in future versions.\n- Parameter - String (`fieldName`): The name of the field.\n"
  },
  "Method <Java>.getMethodDelegate(methodName, parameters)": {
    "prefix": ".getMethodDelegate($methodName, $parameters)",
    "body": ".getMethodDelegate($methodName, $parameters)",
    "description": "<Java>.getMethodDelegate(methodName, parameters)\nThis returns a method delegate for the specified method name and parameters.\nThis should be avoided and replaced with a Arucas function wrapping the call instead.\nFor example: `delegate = (fun() { Java.valueOf('').isBlank(); });`.\nAnother thing to note is that the parameter count parameter is no longer\nused and ignored internally, instead the parameters are calculated when you\ncall the delegate. The parameter remains for backwards compatability.\n- Parameter - String (`methodName`): The name of the method.\n- Parameter - Number (`parameters`): The number of parameters.\n"
  },
  "Method <Java>.setField(fieldName, value)": {
    "prefix": ".setField($fieldName, $value)",
    "body": ".setField($fieldName, $value)",
    "description": "<Java>.setField(fieldName, value)\nThis sets the specified field to the specified value\nThere is no reason for you to be using this method, it will be removed in future versions.\n- Parameter - String (`fieldName`): The name of the field.\n- Parameter - Object (`value`): The value to set the field to, the value type must match the type of the field.\n"
  },
  "Method <Java>.toArucas()": {
    "prefix": ".toArucas()",
    "body": ".toArucas()",
    "description": "<Java>.toArucas()\nThis converts the Java value to an Arucas Value if possible, this may still\nbe of a Java value if it cannot be converted. For example, Strings, Numbers, Lists\nwill be converted but .\n"
  },
  "Static Method Java.arrayOf(values)": {
    "prefix": "Java.arrayOf(values)",
    "body": "Java.arrayOf($values)",
    "description": "Java.arrayOf(values)\nCreates a Java Object array with a given values, this will be the size of the array,\nthis cannot be used to create primitive arrays.\n- Parameter - Object (`values...`): The values to add to the array.\n"
  },
  "Static Method Java.booleanArray(size)": {
    "prefix": "Java.booleanArray(size)",
    "body": "Java.booleanArray($size)",
    "description": "Java.booleanArray(size)\nCreates a Java boolean array with a given size, the array is filled with false\nby default and can be filled with only booleans.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.booleanOf(bool)": {
    "prefix": "Java.booleanOf(bool)",
    "body": "Java.booleanOf($bool)",
    "description": "Java.booleanOf(bool)\nCreates a Java value boolean, to be used in Java.\n- Parameter - Boolean (`bool`): The boolean to convert to a Java boolean.\n"
  },
  "Static Method Java.byteArray(size)": {
    "prefix": "Java.byteArray(size)",
    "body": "Java.byteArray($size)",
    "description": "Java.byteArray(size)\nCreates a Java byte array with a given size, the array is filled with 0's\nby default and can be filled with only bytes.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.byteOf(num)": {
    "prefix": "Java.byteOf(num)",
    "body": "Java.byteOf($num)",
    "description": "Java.byteOf(num)\nCreates a Java value byte, to be used in Java.\n- Parameter - Number (`num`): The number to convert to a Java byte.\n"
  },
  "Static Method Java.callStaticMethod(className, methodName, parameters)": {
    "prefix": "Java.callStaticMethod(className, methodName, parameters)",
    "body": "Java.callStaticMethod($className, $methodName, $parameters)",
    "description": "Java.callStaticMethod(className, methodName, parameters)\nCalls a static method of a Java class.\nThis should be avoided and instead use 'classOf' to get the\ninstance of the class then call the static method on that.\n- Parameter - String (`className`): The name of the class.\n- Parameter - String (`methodName`): The name of the method.\n- Parameter - Object (`parameters...`): Any parameters to call the method with.\n"
  },
  "Static Method Java.charArray(size)": {
    "prefix": "Java.charArray(size)",
    "body": "Java.charArray($size)",
    "description": "Java.charArray(size)\nCreates a Java char array with a given size, the array is filled with null characters's\nby default and can be filled with only chars.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.charOf(char)": {
    "prefix": "Java.charOf(char)",
    "body": "Java.charOf($char)",
    "description": "Java.charOf(char)\nCreates a Java value char, to be used in Java.\n- Parameter - String (`char`): The char to convert to a Java char.\n"
  },
  "Static Method Java.classFromName(className)": {
    "prefix": "Java.classFromName(className)",
    "body": "Java.classFromName($className)",
    "description": "Java.classFromName(className)\nGets a Java class from the name of the class.\n- Parameter - String (`className`): The name of the class you want to get.\n"
  },
  "Static Method Java.classOf(className)": {
    "prefix": "Java.classOf(className)",
    "body": "Java.classOf($className)",
    "description": "Java.classOf(className)\nGets a Java class from the name of the class.\n- Parameter - String (`className`): The name of the class you want to get.\n"
  },
  "Static Method Java.constructClass(className, parameters)": {
    "prefix": "Java.constructClass(className, parameters)",
    "body": "Java.constructClass($className, $parameters)",
    "description": "Java.constructClass(className, parameters)\nThis constructs a Java class with specified class name and parameters.\nThis should be avoided and instead use 'classOf' to get the class\ninstance then call the constructor on that instance.\n- Parameter - String (`className`): The name of the class.\n- Parameter - Object (`parameters...`): Any parameters to pass to the constructor.\n"
  },
  "Static Method Java.consumerOf(function)": {
    "prefix": "Java.consumerOf(function)",
    "body": "Java.consumerOf($function)",
    "description": "Java.consumerOf(function)\nCreates a Java Consumer object from a given function, it must have one\nparameter and any return values will be ignored.\n- Parameter - Function (`function`): The function to be executed.\n"
  },
  "Static Method Java.doubleArray(size)": {
    "prefix": "Java.doubleArray(size)",
    "body": "Java.doubleArray($size)",
    "description": "Java.doubleArray(size)\nCreates a Java double array with a given size, the array is filled with 0's\nby default and can be filled with only doubles.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.doubleOf(num)": {
    "prefix": "Java.doubleOf(num)",
    "body": "Java.doubleOf($num)",
    "description": "Java.doubleOf(num)\nCreates a Java value double, to be used in Java.\n- Parameter - Number (`num`): The number to convert to a Java double.\n"
  },
  "Static Method Java.floatArray(size)": {
    "prefix": "Java.floatArray(size)",
    "body": "Java.floatArray($size)",
    "description": "Java.floatArray(size)\nCreates a Java float array with a given size, the array is filled with 0's\nby default and can be filled with only floats.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.floatOf(num)": {
    "prefix": "Java.floatOf(num)",
    "body": "Java.floatOf($num)",
    "description": "Java.floatOf(num)\nCreates a Java value float, to be used in Java.\n- Parameter - Number (`num`): The number to convert to a Java float.\n"
  },
  "Static Method Java.functionOf(function)": {
    "prefix": "Java.functionOf(function)",
    "body": "Java.functionOf($function)",
    "description": "Java.functionOf(function)\nCreates a Java Function object from a given function.\n- Parameter - Function (`function`): The function to be executed, this must have one parameter and must return a value.\n"
  },
  "Static Method Java.getStaticField(className, fieldName)": {
    "prefix": "Java.getStaticField(className, fieldName)",
    "body": "Java.getStaticField($className, $fieldName)",
    "description": "Java.getStaticField(className, fieldName)\nGets a static field Java value from a Java class.\n- Parameter - String (`className`): The name of the class.\n- Parameter - String (`fieldName`): The name of the field.\n"
  },
  "Static Method Java.getStaticMethodDelegate(className, methodName, parameters)": {
    "prefix": "Java.getStaticMethodDelegate(className, methodName, parameters)",
    "body": "Java.getStaticMethodDelegate($className, $methodName, $parameters)",
    "description": "Java.getStaticMethodDelegate(className, methodName, parameters)\nGets a static method delegate from a Java class, this should\nbe avoided and instance use 'classOf' to get the class instance\nand then call the method on that class instance. The parameter count\nparameter is no longer used internally but remains for backwards compatibility.\n- Parameter - String (`className`): The name of the class.\n- Parameter - String (`methodName`): The name of the method.\n- Parameter - Number (`parameters`): The number of parameters.\n"
  },
  "Static Method Java.implementClass(superclasses, invokeHandler)": {
    "prefix": "Java.implementClass(superclasses, invokeHandler)",
    "body": "Java.implementClass($superclasses, $invokeHandler)",
    "description": "Java.implementClass(superclasses, invokeHandler)\nCreates a new Java class definition extending/implementing the given classes.\n- Parameter - List (`superclasses`): A list of the superclasses of the wanted definition. These should be JavaClass types, there can only be 1 (abstract) class, as many interfaces.\n- Parameter - Function (`invokeHandler`): This function will intercept all method calls, it will be passed the name of the method and any arguments.\n"
  },
  "Static Method Java.intArray(size)": {
    "prefix": "Java.intArray(size)",
    "body": "Java.intArray($size)",
    "description": "Java.intArray(size)\nCreates a Java int array with a given size, the array is filled with 0's\nby default and can be filled with only ints.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.intOf(num)": {
    "prefix": "Java.intOf(num)",
    "body": "Java.intOf($num)",
    "description": "Java.intOf(num)\nCreates a Java value int, to be used in Java.\n- Parameter - Number (`num`): The number to convert to a Java int.\n"
  },
  "Static Method Java.longArray(size)": {
    "prefix": "Java.longArray(size)",
    "body": "Java.longArray($size)",
    "description": "Java.longArray(size)\nCreates a Java long array with a given size, the array is filled with 0's\nby default and can be filled with only longs.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.longOf(num)": {
    "prefix": "Java.longOf(num)",
    "body": "Java.longOf($num)",
    "description": "Java.longOf(num)\nCreates a Java value long, to be used in Java.\n- Parameter - Number (`num`): The number to convert to a Java long.\n"
  },
  "Static Method Java.objectArray(size)": {
    "prefix": "Java.objectArray(size)",
    "body": "Java.objectArray($size)",
    "description": "Java.objectArray(size)\nCreates a Java Object array with a given size, the array is filled with null values\nby default and can be filled with any Java values, this array cannot be expanded.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.predicateOf(function)": {
    "prefix": "Java.predicateOf(function)",
    "body": "Java.predicateOf($function)",
    "description": "Java.predicateOf(function)\nCreates a Java Predicate object from a given function.\n- Parameter - Function (`function`): The function to be executed, this must have one parameter and must return a boolean.\n"
  },
  "Static Method Java.runnableOf(function)": {
    "prefix": "Java.runnableOf(function)",
    "body": "Java.runnableOf($function)",
    "description": "Java.runnableOf(function)\nCreates a Java Runnable object from a given function, this must\nhave no paramters and any return values will be ignored.\n- Parameter - Function (`function`): The function to be executed.\n"
  },
  "Static Method Java.setStaticField(className, fieldName, newValue)": {
    "prefix": "Java.setStaticField(className, fieldName, newValue)",
    "body": "Java.setStaticField($className, $fieldName, $newValue)",
    "description": "Java.setStaticField(className, fieldName, newValue)\nSets a static field in a Java class with a new value.\n- Parameter - String (`className`): The name of the class.\n- Parameter - String (`fieldName`): The name of the field.\n- Parameter - Object (`newValue`): The new value.\n"
  },
  "Static Method Java.shortArray(size)": {
    "prefix": "Java.shortArray(size)",
    "body": "Java.shortArray($size)",
    "description": "Java.shortArray(size)\nCreates a Java short array with a given size, the array is filled with 0's\nby default and can be filled with only shorts.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.shortOf(num)": {
    "prefix": "Java.shortOf(num)",
    "body": "Java.shortOf($num)",
    "description": "Java.shortOf(num)\nCreates a Java value short, to be used in Java.\n- Parameter - Number (`num`): The number to convert to a Java short.\n"
  },
  "Static Method Java.supplierOf(function)": {
    "prefix": "Java.supplierOf(function)",
    "body": "Java.supplierOf($function)",
    "description": "Java.supplierOf(function)\nCreates a Java Supplier object from a given function.\n- Parameter - Function (`function`): The function to be executed, this must have no parameters and must return (supply) a value.\n"
  },
  "Static Method Java.typedArray(type, size)": {
    "prefix": "Java.typedArray(type, size)",
    "body": "Java.typedArray($type, $size)",
    "description": "Java.typedArray(type, size)\nCreates a Java typed array with a given size, the array is filled with null values\nby default and can be filled with the given typed Java values, this array cannot be expanded.\n- Parameter - JavaClass (`type`): The type of the array.\n- Parameter - Number (`size`): The size of the array.\n"
  },
  "Static Method Java.typedArrayOf(castType, values)": {
    "prefix": "Java.typedArrayOf(castType, values)",
    "body": "Java.typedArrayOf($castType, $values)",
    "description": "Java.typedArrayOf(castType, values)\nCreates a Java array with a given type with given values. This will also\nbe the size of the array. If any value does not match the given type an error will be thrown.\n- Parameter - JavaClass (`castType`): The type to cast the arrays to.\n- Parameter - Java (`values...`): The values to add to the array.\n"
  },
  "Static Method Java.valueOf(value)": {
    "prefix": "Java.valueOf(value)",
    "body": "Java.valueOf($value)",
    "description": "Java.valueOf(value)\nConverts any Arucas value into a Java value then wraps it in the Java wrapper and returns it.\n- Parameter - Object (`value`): Any value to get the Java value of.\n"
  },
  "JavaClass Class": {
    "prefix": "JavaClass",
    "body": "JavaClass",
    "description": "The JavaClass class from util.Internal.\nThis class 'acts' as a Java class. You are able to call this class which\nwill invoke the Java class' constructor, and access and assign the static\nfields of the class. This class cannot be instantiated or extended.\n"
  },
  "Json Class": {
    "prefix": "Json",
    "body": "Json",
    "description": "The Json class from util.Json.\nThis class allows you to create and manipulate JSON objects.\nThis class cannot be instantiated or extended.\n"
  },
  "Method <Json>.getValue()": {
    "prefix": ".getValue()",
    "body": ".getValue()",
    "description": "<Json>.getValue()\nThis converts the Json back into an object.\n"
  },
  "Method <Json>.writeToFile(file)": {
    "prefix": ".writeToFile($file)",
    "body": ".writeToFile($file)",
    "description": "<Json>.writeToFile(file)\nThis writes the Json to a file\nif the file given is a directory or cannot be\nwritten to, an error will be thrown.\n- Parameter - File (`file`): The file that you want to write to.\n"
  },
  "Static Method Json.fromFile(file)": {
    "prefix": "Json.fromFile(file)",
    "body": "Json.fromFile($file)",
    "description": "Json.fromFile(file)\nThis will read a file and parse it into a Json, this will throw an error if the file cannot be read.\n- Parameter - File (`file`): The file that you want to parse into a Json.\n"
  },
  "Static Method Json.fromList(list)": {
    "prefix": "Json.fromList(list)",
    "body": "Json.fromList($list)",
    "description": "Json.fromList(list)\nThis converts a list into a Json, an important thing to note is that\nany values that are not Numbers, Booleans, Lists, Maps, or Null will use their\ntoString() member to convert them to a string.\n- Parameter - List (`list`): The list that you want to parse into a Json.\n"
  },
  "Static Method Json.fromMap(map)": {
    "prefix": "Json.fromMap(map)",
    "body": "Json.fromMap($map)",
    "description": "Json.fromMap(map)\nThis converts a map into a Json, an important thing to note is that\nany values that are not Numbers, Booleans, Lists, Maps, or Null will use their\ntoString() member to convert them to a string.\n- Parameter - Map (`map`): The map that you want to parse into a Json.\n"
  },
  "Static Method Json.fromString(string)": {
    "prefix": "Json.fromString(string)",
    "body": "Json.fromString($string)",
    "description": "Json.fromString(string)\nThis converts a string into a Json provided it is formatted correctly,\notherwise throwing an error.\n- Parameter - String (`string`): The string that you want to parse into a Json.\n"
  },
  "KeyBind Class": {
    "prefix": "KeyBind",
    "body": "KeyBind",
    "description": "The KeyBind class from Minecraft.\nThis class allows you to create key binds that can be used, everything is\nhandled for you internally so you just need to regers the key bind and\nthe function you want to run when it is pressed.\n"
  },
  "Constructor new KeyBind(keyName)": {
    "prefix": "new KeyBind($keyName)",
    "body": "new KeyBind($keyName)",
    "description": "new KeyBind(keyName)\nCreates a new key bind.\n- Parameter - String (`keyName`): The name of the key.\n"
  },
  "Method <KeyBind>.getKey()": {
    "prefix": ".getKey()",
    "body": ".getKey()",
    "description": "<KeyBind>.getKey()\nGets the key bind's first key.\n"
  },
  "Method <KeyBind>.getKeys()": {
    "prefix": ".getKeys()",
    "body": ".getKeys()",
    "description": "<KeyBind>.getKeys()\nGets the all of the keys in the key bind.\n"
  },
  "Method <KeyBind>.setCallback(callback)": {
    "prefix": ".setCallback($callback)",
    "body": ".setCallback($callback)",
    "description": "<KeyBind>.setCallback(callback)\nSets the callback function for the key bind.\n- Parameter - Function (`callback`): The callback function.\n"
  },
  "Method <KeyBind>.setKey(keyName)": {
    "prefix": ".setKey($keyName)",
    "body": ".setKey($keyName)",
    "description": "<KeyBind>.setKey(keyName)\nSets the key bind to a new key.\n- Parameter - String (`keyName`): The name of the key.\n"
  },
  "Method <KeyBind>.setKeys(keyNames...)": {
    "prefix": ".setKeys($keyNames...)",
    "body": ".setKeys($keyNames...)",
    "description": "<KeyBind>.setKeys(keyNames...)\nSets the key bind to new keys, you may also pass\nin a list as the parameter, this is to keep compatability.\n- Parameter - String (`keyNames......`): The names of keys.\n"
  },
  "LineShape Class": {
    "prefix": "LineShape",
    "body": "LineShape",
    "description": "The LineShape class from Minecraft.\nThis class allows you to create a line shape which can be used to draw lines in the world.\n"
  },
  "Constructor new LineShape(pos1, pos2)": {
    "prefix": "new LineShape($pos1, $pos2)",
    "body": "new LineShape($pos1, $pos2)",
    "description": "new LineShape(pos1, pos2)\nCreates a new line shape.\n- Parameter - Pos (`pos1`): The starting position of the line.\n- Parameter - Pos (`pos2`): The ending position of the line.\n"
  },
  "Constructor new LineShape(x1, y1, z1, x2, y2, z2)": {
    "prefix": "new LineShape($x1, $y1, $z1, $x2, $y2, $z2)",
    "body": "new LineShape($x1, $y1, $z1, $x2, $y2, $z2)",
    "description": "new LineShape(x1, y1, z1, x2, y2, z2)\nCreates a new line shape.\n- Parameter - Number (`x1`): The x position of the starting position of the line.\n- Parameter - Number (`y1`): The y position of the starting position of the line.\n- Parameter - Number (`z1`): The z position of the starting position of the line.\n- Parameter - Number (`x2`): The x position of the ending position of the line.\n- Parameter - Number (`y2`): The y position of the ending position of the line.\n- Parameter - Number (`z2`): The z position of the ending position of the line.\n"
  },
  "List Class": {
    "prefix": "List",
    "body": "List",
    "description": "The List class.\nThis class is used for collections of ordered elements.\n"
  },
  "Constructor new List()": {
    "prefix": "new List()",
    "body": "new List()",
    "description": "new List()\nThis creates a list, this cannot be called directly, only from child classes.\n"
  },
  "Method <List>.addAll(collection)": {
    "prefix": ".addAll($collection)",
    "body": ".addAll($collection)",
    "description": "<List>.addAll(collection)\nThis allows you to add all the values in another collection to the list.\n- Parameter - Collection (`collection`): The collection you want to add to the list.\n"
  },
  "Method <List>.append(value)": {
    "prefix": ".append($value)",
    "body": ".append($value)",
    "description": "<List>.append(value)\nThis allows you to append a value to the end of the list.\n- Parameter - Object (`value`): The value you want to append.\n"
  },
  "Method <List>.clear()": {
    "prefix": ".clear()",
    "body": ".clear()",
    "description": "<List>.clear()\nThis allows you to clear the list.\n"
  },
  "Method <List>.contains(value)": {
    "prefix": ".contains($value)",
    "body": ".contains($value)",
    "description": "<List>.contains(value)\nThis allows you to check if the list contains a specific value.\n- Parameter - Object (`value`): The value you want to check.\n"
  },
  "Method <List>.containsAll(collection)": {
    "prefix": ".containsAll($collection)",
    "body": ".containsAll($collection)",
    "description": "<List>.containsAll(collection)\nThis allows you to check if the list contains all the values in another collection.\n- Parameter - Collection (`collection`): The collection you want to check agains.\n"
  },
  "Method <List>.filter(predicate)": {
    "prefix": ".filter($predicate)",
    "body": ".filter($predicate)",
    "description": "<List>.filter(predicate)\nThis filters the list using the predicate, a function that either returns\ntrue or false, based on the element on whether it should be kept or not,\nand returns a new list with the filtered elements.\n- Parameter - Function (`predicate`): A function that takes a value and returns Boolean.\n"
  },
  "Method <List>.flatten()": {
    "prefix": ".flatten()",
    "body": ".flatten()",
    "description": "<List>.flatten()\nIf there are any objects in the list that are collections they will\nbe expanded and added to the list. However collections inside those\ncollections will not be flattened, this is returned as a new list.\n"
  },
  "Method <List>.get(index)": {
    "prefix": ".get($index)",
    "body": ".get($index)",
    "description": "<List>.get(index)\nThis allows you to get the value at a specific index, alternative to bracket accessor,\nthis will throw an error if the index given is out of bounds.\n- Parameter - Number (`index`): The index of the value you want to get.\n"
  },
  "Method <List>.indexOf(value)": {
    "prefix": ".indexOf($value)",
    "body": ".indexOf($value)",
    "description": "<List>.indexOf(value)\nThis allows you to get the index of a specific value.\n- Parameter - Object (`value`): The value you want to get the index of.\n"
  },
  "Method <List>.insert(value, index)": {
    "prefix": ".insert($value, $index)",
    "body": ".insert($value, $index)",
    "description": "<List>.insert(value, index)\nThis allows you to insert a value at a specific index, this will throw an error if the index is out of bounds.\n- Parameter - Object (`value`): The value you want to insert.\n- Parameter - Number (`index`): The index you want to insert the value at.\n"
  },
  "Method <List>.lastIndexOf(value)": {
    "prefix": ".lastIndexOf($value)",
    "body": ".lastIndexOf($value)",
    "description": "<List>.lastIndexOf(value)\nThis allows you to get the last index of a specific value.\n- Parameter - Object (`value`): The value you want to get the last index of.\n"
  },
  "Method <List>.map(mapper)": {
    "prefix": ".map($mapper)",
    "body": ".map($mapper)",
    "description": "<List>.map(mapper)\nThis maps the list using the mapper, a function that takes a value and\nreturns a new value, and returns a new list with the mapped elements.\n- Parameter - Function (`mapper`): A function that takes a value and returns a new value.\n"
  },
  "Method <List>.prepend(value)": {
    "prefix": ".prepend($value)",
    "body": ".prepend($value)",
    "description": "<List>.prepend(value)\nThis allows you to prepend a value to the beginning of the list.\n- Parameter - Object (`value`): The value you want to prepend.\n"
  },
  "Method <List>.reduce(reducer)": {
    "prefix": ".reduce($reducer)",
    "body": ".reduce($reducer)",
    "description": "<List>.reduce(reducer)\nThis reduces the list using the reducer, a function that takes an\naccumulated value and a new value and returns the next accumulated value.\n- Parameter - Function (`reducer`): A function that takes a value and returns a new value.\n"
  },
  "Method <List>.reduce(identity, reducer)": {
    "prefix": ".reduce($identity, $reducer)",
    "body": ".reduce($identity, $reducer)",
    "description": "<List>.reduce(identity, reducer)\nThis reduces the list using the reducer starting with an identity.\n- Parameter - Object (`identity`): The identity.\n- Parameter - Function (`reducer`): A function that takes a value and returns a new value.\n"
  },
  "Method <List>.remove(index)": {
    "prefix": ".remove($index)",
    "body": ".remove($index)",
    "description": "<List>.remove(index)\nThis allows you to remove the value at a specific index, alternative to bracket assignment.\nThis will throw an error if the index is out of bounds.\n- Parameter - Number (`index`): The index of the value you want to remove.\n"
  },
  "Method <List>.removeAll(collection)": {
    "prefix": ".removeAll($collection)",
    "body": ".removeAll($collection)",
    "description": "<List>.removeAll(collection)\nThis allows you to remove all the values in another collection from the list.\n- Parameter - Collection (`collection`): The collection you want to remove from the list.\n"
  },
  "Method <List>.retainAll(list)": {
    "prefix": ".retainAll($list)",
    "body": ".retainAll($list)",
    "description": "<List>.retainAll(list)\nThis allows you to retain only the values that are in both lists.\n- Parameter - List (`list`): The list you want to retain values from.\n"
  },
  "Method <List>.reverse()": {
    "prefix": ".reverse()",
    "body": ".reverse()",
    "description": "<List>.reverse()\nThis allows you to reverse the list - this mutates the existing list.\n"
  },
  "Method <List>.set(value, index)": {
    "prefix": ".set($value, $index)",
    "body": ".set($value, $index)",
    "description": "<List>.set(value, index)\nThis allows you to set the value at a specific index, alternative to bracket assignment,\nthis will throw an erroor if the index given is out of bounds.\n- Parameter - Object (`value`): The value you want to set.\n- Parameter - Number (`index`): The index you want to set the value at.\n"
  },
  "Method <List>.shuffle()": {
    "prefix": ".shuffle()",
    "body": ".shuffle()",
    "description": "<List>.shuffle()\nThis allows you to shuffle the list - this mutates the existing list.\n"
  },
  "Method <List>.slice(indexes)": {
    "prefix": ".slice($indexes)",
    "body": ".slice($indexes)",
    "description": "<List>.slice(indexes)\nThis creates a new list with the desired contents from the list.\n- Parameter - Iterable (`indexes`): An iterable object containing the indexes you want to slice.\n"
  },
  "Method <List>.sort()": {
    "prefix": ".sort()",
    "body": ".sort()",
    "description": "<List>.sort()\nThis allows you to sort the list using the elements compare method.\n"
  },
  "Method <List>.sort(comparator)": {
    "prefix": ".sort($comparator)",
    "body": ".sort($comparator)",
    "description": "<List>.sort(comparator)\nThis allows you to sort the list using a comparator function.\n- Parameter - Function (`comparator`): The comparator function.\n"
  },
  "LivingEntity Class": {
    "prefix": "LivingEntity",
    "body": "LivingEntity",
    "description": "The LivingEntity class from Minecraft.\nThis class extends Entity and so inherits all of their methods too,\nLivingEntities are any entities that are alive, so all mobs.\n"
  },
  "Method <LivingEntity>.getHealth()": {
    "prefix": ".getHealth()",
    "body": ".getHealth()",
    "description": "<LivingEntity>.getHealth()\nThis gets the LivingEntity's current health.\n"
  },
  "Method <LivingEntity>.getStatusEffects()": {
    "prefix": ".getStatusEffects()",
    "body": ".getStatusEffects()",
    "description": "<LivingEntity>.getStatusEffects()\nThis gets the LivingEntity's status effects, you can find\na list of all the ids of the status effects\n[here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Effects).\n"
  },
  "Method <LivingEntity>.isFlyFalling()": {
    "prefix": ".isFlyFalling()",
    "body": ".isFlyFalling()",
    "description": "<LivingEntity>.isFlyFalling()\nThis checks if the LivingEntity is fly falling (gliding with elytra).\n"
  },
  "Map Class": {
    "prefix": "Map",
    "body": "Map",
    "description": "The Map class.\nThis class is used to create a map of objects, using keys and values.\nThis class cannot be directly instantiated, but can be extended to create a map of your own type.\n"
  },
  "Constructor new Map()": {
    "prefix": "new Map()",
    "body": "new Map()",
    "description": "new Map()\nThis creates an empty map, this cannot be called directly, only from child classes.\n"
  },
  "Method <Map>.clear()": {
    "prefix": ".clear()",
    "body": ".clear()",
    "description": "<Map>.clear()\nThis allows you to clear the map of all the keys and values.\n"
  },
  "Method <Map>.containsKey(key)": {
    "prefix": ".containsKey($key)",
    "body": ".containsKey($key)",
    "description": "<Map>.containsKey(key)\nThis allows you to check if the map contains a specific key.\n- Parameter - Object (`key`): The key you want to check.\n"
  },
  "Method <Map>.containsValue(value)": {
    "prefix": ".containsValue($value)",
    "body": ".containsValue($value)",
    "description": "<Map>.containsValue(value)\nThis allows you to check if the map contains a specific value.\n- Parameter - Object (`value`): The value you want to check.\n"
  },
  "Method <Map>.get(key)": {
    "prefix": ".get($key)",
    "body": ".get($key)",
    "description": "<Map>.get(key)\nThis allows you to get the value of a key in the map.\n- Parameter - Object (`key`): The key you want to get the value of.\n"
  },
  "Method <Map>.getKeys()": {
    "prefix": ".getKeys()",
    "body": ".getKeys()",
    "description": "<Map>.getKeys()\nThis allows you to get the keys in the map.\n"
  },
  "Method <Map>.getValues()": {
    "prefix": ".getValues()",
    "body": ".getValues()",
    "description": "<Map>.getValues()\nThis allows you to get the values in the map.\n"
  },
  "Method <Map>.map(remapper)": {
    "prefix": ".map($remapper)",
    "body": ".map($remapper)",
    "description": "<Map>.map(remapper)\nThis allows you to map the values in the map and returns a new map.\n- Parameter - Function (`remapper`): The function you want to map the values with.\n"
  },
  "Method <Map>.put(key, value)": {
    "prefix": ".put($key, $value)",
    "body": ".put($key, $value)",
    "description": "<Map>.put(key, value)\nThis allows you to put a key and value in the map.\n- Parameter - Object (`key`): The key you want to put.\n- Parameter - Object (`value`): The value you want to put.\n"
  },
  "Method <Map>.putAll(anotherMap)": {
    "prefix": ".putAll($anotherMap)",
    "body": ".putAll($anotherMap)",
    "description": "<Map>.putAll(anotherMap)\nThis allows you to put all the keys and values of another map into this map.\n- Parameter - Map (`anotherMap`): The map you want to merge into this map.\n"
  },
  "Method <Map>.putIfAbsent(key, value)": {
    "prefix": ".putIfAbsent($key, $value)",
    "body": ".putIfAbsent($key, $value)",
    "description": "<Map>.putIfAbsent(key, value)\nThis allows you to put a key and value in the map if it doesn't exist.\n- Parameter - Object (`key`): The key you want to put.\n- Parameter - Object (`value`): The value you want to put.\n"
  },
  "Method <Map>.remove(key)": {
    "prefix": ".remove($key)",
    "body": ".remove($key)",
    "description": "<Map>.remove(key)\nThis allows you to remove a key and its value from the map.\n- Parameter - Object (`key`): The key you want to remove.\n"
  },
  "Static Method Map.unordered()": {
    "prefix": "Map.unordered()",
    "body": "Map.unordered()",
    "description": "Map.unordered()\nThis function allows you to create an unordered map.\n"
  },
  "Material Class": {
    "prefix": "Material",
    "body": "Material",
    "description": "The Material class from Minecraft.\nThis class represents all possible item and block types\nand allows you to convert them into instances of ItemStacks and Blocks.\n"
  },
  "Method <Material>.asBlock()": {
    "prefix": ".asBlock()",
    "body": ".asBlock()",
    "description": "<Material>.asBlock()\nThis converts the material into a Block.\nIf it cannot be converted an error will be thrown.\n"
  },
  "Method <Material>.asItemStack()": {
    "prefix": ".asItemStack()",
    "body": ".asItemStack()",
    "description": "<Material>.asItemStack()\nThis converts the material into an ItemStack.\nIf it cannot be converted an error will be thrown.\n"
  },
  "Method <Material>.getFullId()": {
    "prefix": ".getFullId()",
    "body": ".getFullId()",
    "description": "<Material>.getFullId()\nThis returns the full id of the material, for example: 'minecraft:diamond'.\n"
  },
  "Method <Material>.getId()": {
    "prefix": ".getId()",
    "body": ".getId()",
    "description": "<Material>.getId()\nThis returns the id of the material, for example: 'diamond'.\n"
  },
  "Method <Material>.getTranslatedName()": {
    "prefix": ".getTranslatedName()",
    "body": ".getTranslatedName()",
    "description": "<Material>.getTranslatedName()\nThis gets the translated name of the ItemStack, for example: \nMaterial.DIAMOND_SWORD would return 'Diamond Sword' if your language is English.\n"
  },
  "Static Method Material.of(id)": {
    "prefix": "Material.of(id)",
    "body": "Material.of($id)",
    "description": "Material.of(id)\nThis converts a block or item id into a Material.\nThis method will throw an error if the id is invalid.\n- Parameter - String (`id`): The id of the block or item.\n"
  },
  "Math Class": {
    "prefix": "Math",
    "body": "Math",
    "description": "The Math class.\nProvides many basic math functions. This is a utility class, and cannot be constructed.\n"
  },
  "Static Field Math.e": {
    "prefix": "Math.e",
    "body": "Math.e",
    "description": "Math.e\nThe value of e."
  },
  "Static Field Math.pi": {
    "prefix": "Math.pi",
    "body": "Math.pi",
    "description": "Math.pi\nThe value of pi."
  },
  "Static Field Math.root2": {
    "prefix": "Math.root2",
    "body": "Math.root2",
    "description": "Math.root2\nThe value of root 2."
  },
  "Static Method Math.abs(num)": {
    "prefix": "Math.abs(num)",
    "body": "Math.abs($num)",
    "description": "Math.abs(num)\nReturns the absolute value of a number.\n- Parameter - Number (`num`): The number to get the absolute value of.\n"
  },
  "Static Method Math.arccos(num)": {
    "prefix": "Math.arccos(num)",
    "body": "Math.arccos($num)",
    "description": "Math.arccos(num)\nReturns the arc cosine of a number.\n- Parameter - Number (`num`): The number to get the arc cosine of.\n"
  },
  "Static Method Math.arcsin(num)": {
    "prefix": "Math.arcsin(num)",
    "body": "Math.arcsin($num)",
    "description": "Math.arcsin(num)\nReturns the arc sine of a number.\n- Parameter - Number (`num`): The number to get the arc sine of.\n"
  },
  "Static Method Math.arctan(num)": {
    "prefix": "Math.arctan(num)",
    "body": "Math.arctan($num)",
    "description": "Math.arctan(num)\nReturns the arc tangent of a number.\n- Parameter - Number (`num`): The number to get the arc tangent of.\n"
  },
  "Static Method Math.arctan2(y, x)": {
    "prefix": "Math.arctan2(y, x)",
    "body": "Math.arctan2($y, $x)",
    "description": "Math.arctan2(y, x)\nReturns the angle theta of the polar coordinates (r, theta) that correspond to the rectangular\ncoordinates (x, y) by computing the arc tangent of the value y / x.\n- Parameter - Number (`y`): The ordinate coordinate.\n- Parameter - Number (`x`): The abscissa coordinate.\n"
  },
  "Static Method Math.ceil(num)": {
    "prefix": "Math.ceil(num)",
    "body": "Math.ceil($num)",
    "description": "Math.ceil(num)\nRounds a number up to the nearest integer.\n- Parameter - Number (`num`): The number to round.\n"
  },
  "Static Method Math.clamp(value, min, max)": {
    "prefix": "Math.clamp(value, min, max)",
    "body": "Math.clamp($value, $min, $max)",
    "description": "Math.clamp(value, min, max)\nClamps a value between a minimum and maximum.\n- Parameter - Number (`value`): The value to clamp.\n- Parameter - Number (`min`): The minimum.\n- Parameter - Number (`max`): The maximum.\n"
  },
  "Static Method Math.cos(num)": {
    "prefix": "Math.cos(num)",
    "body": "Math.cos($num)",
    "description": "Math.cos(num)\nReturns the cosine of a number.\n- Parameter - Number (`num`): The number to get the cosine of.\n"
  },
  "Static Method Math.cosec(num)": {
    "prefix": "Math.cosec(num)",
    "body": "Math.cosec($num)",
    "description": "Math.cosec(num)\nReturns the cosecant of a number.\n- Parameter - Number (`num`): The number to get the cosecant of.\n"
  },
  "Static Method Math.cosh(num)": {
    "prefix": "Math.cosh(num)",
    "body": "Math.cosh($num)",
    "description": "Math.cosh(num)\nReturns the hyperbolic cosine of a number.\n- Parameter - Number (`num`): The number to get the hyperbolic cosine of.\n"
  },
  "Static Method Math.cot(num)": {
    "prefix": "Math.cot(num)",
    "body": "Math.cot($num)",
    "description": "Math.cot(num)\nReturns the cotangent of a number.\n- Parameter - Number (`num`): The number to get the cotangent of.\n"
  },
  "Static Method Math.floor(num)": {
    "prefix": "Math.floor(num)",
    "body": "Math.floor($num)",
    "description": "Math.floor(num)\nRounds a number down to the nearest integer.\n- Parameter - Number (`num`): The number to round.\n"
  },
  "Static Method Math.lerp(start, end, delta)": {
    "prefix": "Math.lerp(start, end, delta)",
    "body": "Math.lerp($start, $end, $delta)",
    "description": "Math.lerp(start, end, delta)\nLinear interpolation between two numbers.\n- Parameter - Number (`start`): The first number.\n- Parameter - Number (`end`): The second number.\n- Parameter - Number (`delta`): The interpolation factor.\n"
  },
  "Static Method Math.ln(num)": {
    "prefix": "Math.ln(num)",
    "body": "Math.ln($num)",
    "description": "Math.ln(num)\nReturns the natural logarithm of a number.\n- Parameter - Number (`num`): The number to get the logarithm of.\n"
  },
  "Static Method Math.log(base, num)": {
    "prefix": "Math.log(base, num)",
    "body": "Math.log($base, $num)",
    "description": "Math.log(base, num)\nReturns the logarithm of a number with a specified base.\n- Parameter - Number (`base`): The base.\n- Parameter - Number (`num`): The number to get the logarithm of.\n"
  },
  "Static Method Math.log10(num)": {
    "prefix": "Math.log10(num)",
    "body": "Math.log10($num)",
    "description": "Math.log10(num)\nReturns the base 10 logarithm of a number.\n- Parameter - Number (`num`): The number to get the logarithm of.\n"
  },
  "Static Method Math.max(num1, num2)": {
    "prefix": "Math.max(num1, num2)",
    "body": "Math.max($num1, $num2)",
    "description": "Math.max(num1, num2)\nReturns the largest number.\n- Parameter - Number (`num1`): The first number to compare.\n- Parameter - Number (`num2`): The second number to compare.\n"
  },
  "Static Method Math.min(num1, num2)": {
    "prefix": "Math.min(num1, num2)",
    "body": "Math.min($num1, $num2)",
    "description": "Math.min(num1, num2)\nReturns the smallest number.\n- Parameter - Number (`num1`): The first number to compare.\n- Parameter - Number (`num2`): The second number to compare.\n"
  },
  "Static Method Math.mod(num1, num2)": {
    "prefix": "Math.mod(num1, num2)",
    "body": "Math.mod($num1, $num2)",
    "description": "Math.mod(num1, num2)\nReturns the modulus of a division.\n- Parameter - Number (`num1`): The number to divide.\n- Parameter - Number (`num2`): The divisor.\n"
  },
  "Static Method Math.rem(num1, num2)": {
    "prefix": "Math.rem(num1, num2)",
    "body": "Math.rem($num1, $num2)",
    "description": "Math.rem(num1, num2)\nReturns the remainder of a division.\n- Parameter - Number (`num1`): The number to divide.\n- Parameter - Number (`num2`): The divisor.\n"
  },
  "Static Method Math.round(num)": {
    "prefix": "Math.round(num)",
    "body": "Math.round($num)",
    "description": "Math.round(num)\nRounds a number to the nearest integer.\n- Parameter - Number (`num`): The number to round.\n"
  },
  "Static Method Math.sec(num)": {
    "prefix": "Math.sec(num)",
    "body": "Math.sec($num)",
    "description": "Math.sec(num)\nReturns the secant of a number.\n- Parameter - Number (`num`): The number to get the secant of.\n"
  },
  "Static Method Math.signum(num)": {
    "prefix": "Math.signum(num)",
    "body": "Math.signum($num)",
    "description": "Math.signum(num)\nReturns the sign of a number, 1 if the number is positive,\n-1 if the number is negative, and 0 if the number is 0.\n- Parameter - Number (`num`): The number to get the sign of.\n"
  },
  "Static Method Math.sin(num)": {
    "prefix": "Math.sin(num)",
    "body": "Math.sin($num)",
    "description": "Math.sin(num)\nReturns the sine of a number.\n- Parameter - Number (`num`): The number to get the sine of.\n"
  },
  "Static Method Math.sinh(num)": {
    "prefix": "Math.sinh(num)",
    "body": "Math.sinh($num)",
    "description": "Math.sinh(num)\nReturns the hyperbolic sine of a number.\n- Parameter - Number (`num`): The number to get the hyperbolic sine of.\n"
  },
  "Static Method Math.sqrt(num)": {
    "prefix": "Math.sqrt(num)",
    "body": "Math.sqrt($num)",
    "description": "Math.sqrt(num)\nReturns the square root of a number.\n- Parameter - Number (`num`): The number to square root.\n"
  },
  "Static Method Math.tan(num)": {
    "prefix": "Math.tan(num)",
    "body": "Math.tan($num)",
    "description": "Math.tan(num)\nReturns the tangent of a number.\n- Parameter - Number (`num`): The number to get the tangent of.\n"
  },
  "Static Method Math.tanh(num)": {
    "prefix": "Math.tanh(num)",
    "body": "Math.tanh($num)",
    "description": "Math.tanh(num)\nReturns the hyperbolic tangent of a number.\n- Parameter - Number (`num`): The number to get the hyperbolic tangent of.\n"
  },
  "Static Method Math.toDegrees(num)": {
    "prefix": "Math.toDegrees(num)",
    "body": "Math.toDegrees($num)",
    "description": "Math.toDegrees(num)\nConverts a number from radians to degrees.\n- Parameter - Number (`num`): The number to convert.\n"
  },
  "Static Method Math.toRadians(num)": {
    "prefix": "Math.toRadians(num)",
    "body": "Math.toRadians($num)",
    "description": "Math.toRadians(num)\nConverts a number from degrees to radians.\n- Parameter - Number (`num`): The number to convert.\n"
  },
  "MerchantScreen Class": {
    "prefix": "MerchantScreen",
    "body": "MerchantScreen",
    "description": "The MerchantScreen class from Minecraft.\nThis class extends Screen and so inherits all of their methods too,\nthis class is used to add functionality to trading screens.\n"
  },
  "Method <MerchantScreen>.clearTrade()": {
    "prefix": ".clearTrade()",
    "body": ".clearTrade()",
    "description": "<MerchantScreen>.clearTrade()\nThis clears the currently selected trade.\nYou must be inside the merchant GUI or an error will be thrown.\n"
  },
  "Method <MerchantScreen>.doesVillagerHaveTrade(materialLike)": {
    "prefix": ".doesVillagerHaveTrade($materialLike)",
    "body": ".doesVillagerHaveTrade($materialLike)",
    "description": "<MerchantScreen>.doesVillagerHaveTrade(materialLike)\nThis checks if the villager has a trade for a certain item.\nYou must be inside the merchant GUI or an error will be thrown.\n- Parameter - Material (`materialLike`): The item or material to check for.\n"
  },
  "Method <MerchantScreen>.getIndexOfTradeItem(material)": {
    "prefix": ".getIndexOfTradeItem($material)",
    "body": ".getIndexOfTradeItem($material)",
    "description": "<MerchantScreen>.getIndexOfTradeItem(material)\nThis gets the index of a trade for a certain item.\nYou must be inside the merchant GUI or an error will be thrown.\n- Parameter - Material (`material`): The item to get the index of.\n"
  },
  "Method <MerchantScreen>.getPriceForIndex(index)": {
    "prefix": ".getPriceForIndex($index)",
    "body": ".getPriceForIndex($index)",
    "description": "<MerchantScreen>.getPriceForIndex(index)\nThis gets the price of a trade at a certain index.\nYou must be inside the merchant GUI or an error will be thrown.\n- Parameter - Number (`index`): The index of the trade.\n"
  },
  "Method <MerchantScreen>.getTradeItemForIndex(index)": {
    "prefix": ".getTradeItemForIndex($index)",
    "body": ".getTradeItemForIndex($index)",
    "description": "<MerchantScreen>.getTradeItemForIndex(index)\nThis gets the item stack of a trade at a certain index.\nYou must be inside the merchant GUI or an error will be thrown.\n- Parameter - Number (`index`): The index of the trade.\n"
  },
  "Method <MerchantScreen>.getTradeList()": {
    "prefix": ".getTradeList()",
    "body": ".getTradeList()",
    "description": "<MerchantScreen>.getTradeList()\nThis gets a list of all the merchant's trades.\n"
  },
  "Method <MerchantScreen>.getTradeListSize()": {
    "prefix": ".getTradeListSize()",
    "body": ".getTradeListSize()",
    "description": "<MerchantScreen>.getTradeListSize()\nThis gets the size of all the trades available.\n"
  },
  "Method <MerchantScreen>.getVillagerLevel()": {
    "prefix": ".getVillagerLevel()",
    "body": ".getVillagerLevel()",
    "description": "<MerchantScreen>.getVillagerLevel()\nThis gets the level of the villager, this will\nthrow an error if you are not trading with a villager.\nThe level can be between 1 - 5 from Novice to Master.\n"
  },
  "Method <MerchantScreen>.getVillagerXp()": {
    "prefix": ".getVillagerXp()",
    "body": ".getVillagerXp()",
    "description": "<MerchantScreen>.getVillagerXp()\nThis gets the amount of xp in the villagers xp bar,\nThe total amount of xp is hardcoded for each level.\nLevel 2 requires 10 xp, 3 requires 70 (60 xp from 2 -> 3),\n4 requires 150 (80 xp from 3 -> 4), 5 requires 250\n(100 xp from 4 -> 5). 250 is the max xp a villager can have.\n"
  },
  "Method <MerchantScreen>.isTradeDisabled(index)": {
    "prefix": ".isTradeDisabled($index)",
    "body": ".isTradeDisabled($index)",
    "description": "<MerchantScreen>.isTradeDisabled(index)\nThis returns true if a trade is disabled at an index.\n- Parameter - Number (`index`): The index of the trade.\n"
  },
  "Method <MerchantScreen>.isTradeSelected()": {
    "prefix": ".isTradeSelected()",
    "body": ".isTradeSelected()",
    "description": "<MerchantScreen>.isTradeSelected()\nThis returns true if a trade is selected.\n"
  },
  "Method <MerchantScreen>.selectTrade(index)": {
    "prefix": ".selectTrade($index)",
    "body": ".selectTrade($index)",
    "description": "<MerchantScreen>.selectTrade(index)\nThis selects the currently selected trade, as if you were to click it.\nYou must be inside the merchant GUI or an error will be thrown.\n- Parameter - Number (`index`): The index of the trade.\n"
  },
  "Method <MerchantScreen>.tradeIndex(index)": {
    "prefix": ".tradeIndex($index)",
    "body": ".tradeIndex($index)",
    "description": "<MerchantScreen>.tradeIndex(index)\nThis makes your player trade with the merchant at a certain index.\nYou must be inside the merchant GUI or an error will be thrown.\n- Parameter - Number (`index`): The index of the trade.\n"
  },
  "Method <MerchantScreen>.tradeSelected()": {
    "prefix": ".tradeSelected()",
    "body": ".tradeSelected()",
    "description": "<MerchantScreen>.tradeSelected()\nThis trades the currently selected trade.\nYou must be inside the merchant GUI or an error will be thrown.\n"
  },
  "Method <MerchantScreen>.tradeSelectedAndThrow()": {
    "prefix": ".tradeSelectedAndThrow()",
    "body": ".tradeSelectedAndThrow()",
    "description": "<MerchantScreen>.tradeSelectedAndThrow()\nThis trades the currently selected trade and throws the items that were traded.\nYou must be inside the merchant GUI or an error will be thrown.\n"
  },
  "MinecraftClient Class": {
    "prefix": "MinecraftClient",
    "body": "MinecraftClient",
    "description": "The MinecraftClient class from Minecraft.\nThis allows for many core interactions with the MinecraftClient.\n"
  },
  "Method <MinecraftClient>.addCommand(command)": {
    "prefix": ".addCommand($command)",
    "body": ".addCommand($command)",
    "description": "<MinecraftClient>.addCommand(command)\nThis allows you to register your own client side command in game.\n- Parameter - Map (`command`): A command map or a command builder.\n"
  },
  "Method <MinecraftClient>.canSendScriptPacket()": {
    "prefix": ".canSendScriptPacket()",
    "body": ".canSendScriptPacket()",
    "description": "<MinecraftClient>.canSendScriptPacket()\nReturns whether the server supports client script packets.\n"
  },
  "Method <MinecraftClient>.clearChat()": {
    "prefix": ".clearChat()",
    "body": ".clearChat()",
    "description": "<MinecraftClient>.clearChat()\nThis will clear the chat hud.\n"
  },
  "Method <MinecraftClient>.completionsForCommand(command)": {
    "prefix": ".completionsForCommand($command)",
    "body": ".completionsForCommand($command)",
    "description": "<MinecraftClient>.completionsForCommand(command)\nThis gets a list of completions for a given command.\n- Parameter - String (`command`): The command to get suggestions for.\n"
  },
  "Method <MinecraftClient>.editSign(position, strings)": {
    "prefix": ".editSign($position, $strings)",
    "body": ".editSign($position, $strings)",
    "description": "<MinecraftClient>.editSign(position, strings)\nThis allows you to edit sign at certain position with given string(lines), up to 4 lines.\nThis function does not check if sign is editable / is in position.\n- Parameter - Pos (`position`): The position of sign.\n- Parameter - String (`strings...`): The lines for the sign, requires 1 string and up to 4 strings.\n"
  },
  "Method <MinecraftClient>.getClientRenderDistance()": {
    "prefix": ".getClientRenderDistance()",
    "body": ".getClientRenderDistance()",
    "description": "<MinecraftClient>.getClientRenderDistance()\nThis returns the current render distance set on the client.\n"
  },
  "Method <MinecraftClient>.getCursorStack()": {
    "prefix": ".getCursorStack()",
    "body": ".getCursorStack()",
    "description": "<MinecraftClient>.getCursorStack()\nThis returns the item stack that is currently being held by the cursor.\n"
  },
  "Method <MinecraftClient>.getEssentialClientValue(ruleName)": {
    "prefix": ".getEssentialClientValue($ruleName)",
    "body": ".getEssentialClientValue($ruleName)",
    "description": "<MinecraftClient>.getEssentialClientValue(ruleName)\nThis gets the value of the given client rule.\nThis will throw an error if the rule name is invalid.\n- Parameter - String (`ruleName`): The client rule.\n"
  },
  "Method <MinecraftClient>.getFps()": {
    "prefix": ".getFps()",
    "body": ".getFps()",
    "description": "<MinecraftClient>.getFps()\nThis gets the current fps.\n"
  },
  "Method <MinecraftClient>.getLatestChatMessage()": {
    "prefix": ".getLatestChatMessage()",
    "body": ".getLatestChatMessage()",
    "description": "<MinecraftClient>.getLatestChatMessage()\nThis will return the latest chat message.\n"
  },
  "Method <MinecraftClient>.getModList()": {
    "prefix": ".getModList()",
    "body": ".getModList()",
    "description": "<MinecraftClient>.getModList()\nThis gets a list of all the mod ids of the mods installed.\n"
  },
  "Method <MinecraftClient>.getOnlinePlayerNames()": {
    "prefix": ".getOnlinePlayerNames()",
    "body": ".getOnlinePlayerNames()",
    "description": "<MinecraftClient>.getOnlinePlayerNames()\nThis will get a list of all the online player's names.\n"
  },
  "Method <MinecraftClient>.getOnlinePlayerNamesAndUuids()": {
    "prefix": ".getOnlinePlayerNamesAndUuids()",
    "body": ".getOnlinePlayerNamesAndUuids()",
    "description": "<MinecraftClient>.getOnlinePlayerNamesAndUuids()\nThis will get a map of all the online player's names to their uuids.\n"
  },
  "Method <MinecraftClient>.getOnlinePlayerUuids()": {
    "prefix": ".getOnlinePlayerUuids()",
    "body": ".getOnlinePlayerUuids()",
    "description": "<MinecraftClient>.getOnlinePlayerUuids()\nThis will get a list of all the online player's uuids.\n"
  },
  "Method <MinecraftClient>.getPing()": {
    "prefix": ".getPing()",
    "body": ".getPing()",
    "description": "<MinecraftClient>.getPing()\nThis gets the current connected server's ping.\nThis will throw an error if the client is not connected to a server.\n"
  },
  "Method <MinecraftClient>.getPlayer()": {
    "prefix": ".getPlayer()",
    "body": ".getPlayer()",
    "description": "<MinecraftClient>.getPlayer()\nThis returns the current player on the client.\n"
  },
  "Method <MinecraftClient>.getRunDirectory()": {
    "prefix": ".getRunDirectory()",
    "body": ".getRunDirectory()",
    "description": "<MinecraftClient>.getRunDirectory()\nReturns the directory where the client is running.\n"
  },
  "Method <MinecraftClient>.getScriptsPath()": {
    "prefix": ".getScriptsPath()",
    "body": ".getScriptsPath()",
    "description": "<MinecraftClient>.getScriptsPath()\nThis gets the script directory path, this is where all scripts are stored.\n"
  },
  "Method <MinecraftClient>.getServerIp()": {
    "prefix": ".getServerIp()",
    "body": ".getServerIp()",
    "description": "<MinecraftClient>.getServerIp()\nThis will return the server ip.\n"
  },
  "Method <MinecraftClient>.getServerName()": {
    "prefix": ".getServerName()",
    "body": ".getServerName()",
    "description": "<MinecraftClient>.getServerName()\nThis gets the current connected server's name that you have set it to in the multiplayer screen.\n"
  },
  "Method <MinecraftClient>.getVersion()": {
    "prefix": ".getVersion()",
    "body": ".getVersion()",
    "description": "<MinecraftClient>.getVersion()\nThis returns the current version of Minecraft you are playing.\n"
  },
  "Method <MinecraftClient>.getWorld()": {
    "prefix": ".getWorld()",
    "body": ".getWorld()",
    "description": "<MinecraftClient>.getWorld()\nThis returns the world that is currently being played on.\n"
  },
  "Method <MinecraftClient>.holdKey(key, milliseconds)": {
    "prefix": ".holdKey($key, $milliseconds)",
    "body": ".holdKey($key, $milliseconds)",
    "description": "<MinecraftClient>.holdKey(key, milliseconds)\nThis allows you to simulate a key being held inside of Minecraft, this will press, hold, and release.\nThis will throw an error if the given key is unknown.\n- Parameter - String (`key`): The key to hold.\n- Parameter - Number (`milliseconds`): The number of milliseconds you want it held for.\n"
  },
  "Method <MinecraftClient>.isInSinglePlayer()": {
    "prefix": ".isInSinglePlayer()",
    "body": ".isInSinglePlayer()",
    "description": "<MinecraftClient>.isInSinglePlayer()\nThis will return true if the client is in single player mode.\n"
  },
  "Method <MinecraftClient>.parseStringToNbt(string)": {
    "prefix": ".parseStringToNbt($string)",
    "body": ".parseStringToNbt($string)",
    "description": "<MinecraftClient>.parseStringToNbt(string)\nThis parses a string and turns it into a Nbt compound.\n- Parameter - String (`string`): The string to parse.\n"
  },
  "Method <MinecraftClient>.playSound(soundId, volume, pitch)": {
    "prefix": ".playSound($soundId, $volume, $pitch)",
    "body": ".playSound($soundId, $volume, $pitch)",
    "description": "<MinecraftClient>.playSound(soundId, volume, pitch)\nThis plays the given sound with the given volume and pitch around the player\nsound id's can be found [here](https://minecraft.fandom.com/wiki/Sounds.json#Sound_events).\n- Parameter - String (`soundId`): The sound id you want to play.\n- Parameter - Number (`volume`): The volume of the sound.\n- Parameter - Number (`pitch`): The pitch of the sound.\n"
  },
  "Method <MinecraftClient>.playerNameFromUuid(uuid)": {
    "prefix": ".playerNameFromUuid($uuid)",
    "body": ".playerNameFromUuid($uuid)",
    "description": "<MinecraftClient>.playerNameFromUuid(uuid)\nThis will return the player name from the given uuid.\nThe player name is fetched from the Mojang API, this is\nintended for use to get a player's name who is not online.\n- Parameter - String (`uuid`): The uuid as a string.\n"
  },
  "Method <MinecraftClient>.pressKey(key)": {
    "prefix": ".pressKey($key)",
    "body": ".pressKey($key)",
    "description": "<MinecraftClient>.pressKey(key)\nThis allows you to simulate a key press inside of Minecraft, this will only press the key down.\nThis will throw an error if the key is unknown.\n- Parameter - String (`key`): The key to press.\n"
  },
  "Method <MinecraftClient>.releaseKey(key)": {
    "prefix": ".releaseKey($key)",
    "body": ".releaseKey($key)",
    "description": "<MinecraftClient>.releaseKey(key)\nThis allows you to simulate a key release inside of Minecraft, this\nis useful for keys that only work on release, for example `F3`, this\nwill throw an error if the key is unknown.\n- Parameter - String (`key`): The key to release.\n"
  },
  "Method <MinecraftClient>.renderFloatingItem(material)": {
    "prefix": ".renderFloatingItem($material)",
    "body": ".renderFloatingItem($material)",
    "description": "<MinecraftClient>.renderFloatingItem(material)\nThis renders an item in front of the player using the totem of undying animation.\n- Parameter - Material (`material`): The material to render.\n"
  },
  "Method <MinecraftClient>.resetEssentialClientRule(ruleName)": {
    "prefix": ".resetEssentialClientRule($ruleName)",
    "body": ".resetEssentialClientRule($ruleName)",
    "description": "<MinecraftClient>.resetEssentialClientRule(ruleName)\nThis resets the given client rule to its default value.\nThis will throw an error if the rule name is invalid.\n- Parameter - String (`ruleName`): The client rule.\n"
  },
  "Method <MinecraftClient>.run(function)": {
    "prefix": ".run($function)",
    "body": ".run($function)",
    "description": "<MinecraftClient>.run(function)\nThis runs the given function on the main thread.\n- Parameter - Function (`function`): The function to run.\n"
  },
  "Method <MinecraftClient>.runOnMainThread(function)": {
    "prefix": ".runOnMainThread($function)",
    "body": ".runOnMainThread($function)",
    "description": "<MinecraftClient>.runOnMainThread(function)\nThis runs the given function on the main thread.\n- Parameter - Function (`function`): The function to run.\n"
  },
  "Method <MinecraftClient>.screenshot()": {
    "prefix": ".screenshot()",
    "body": ".screenshot()",
    "description": "<MinecraftClient>.screenshot()\nThis makes the client take a screenshot.\n"
  },
  "Method <MinecraftClient>.screenshot(name)": {
    "prefix": ".screenshot($name)",
    "body": ".screenshot($name)",
    "description": "<MinecraftClient>.screenshot(name)\nThis makes the client take a screenshot and saves it with a given name.\n- Parameter - String (`name`): The name of the file.\n"
  },
  "Method <MinecraftClient>.sendScriptPacket(values...)": {
    "prefix": ".sendScriptPacket($values...)",
    "body": ".sendScriptPacket($values...)",
    "description": "<MinecraftClient>.sendScriptPacket(values...)\nThis sends a script packet to the server\nYou can send the follow types of values:\nBoolean, Number, String, List (of numbers), Text, ItemStack, Pos, and NbtMaps\nYou can send byte, int, and long arrays by using the strings 'b', 'i', and 'l' at the start of the list.\n- Parameter - Object (`values......`): The data you want to send to the server.\n"
  },
  "Method <MinecraftClient>.setClientRenderDistance(number)": {
    "prefix": ".setClientRenderDistance($number)",
    "body": ".setClientRenderDistance($number)",
    "description": "<MinecraftClient>.setClientRenderDistance(number)\nThis sets the render distance on the client.\n- Parameter - Number (`number`): The render distance.\n"
  },
  "Method <MinecraftClient>.setCursorStack(itemStack)": {
    "prefix": ".setCursorStack($itemStack)",
    "body": ".setCursorStack($itemStack)",
    "description": "<MinecraftClient>.setCursorStack(itemStack)\nThis sets the item stack that is currently being held by the cursor, this does not work\nin normal screens only in FakeScreens, this does not actually pick up an item just display like you have.\n- Parameter - ItemStack (`itemStack`): The item stack to set.\n"
  },
  "Method <MinecraftClient>.setEssentialClientRule(ruleName, value)": {
    "prefix": ".setEssentialClientRule($ruleName, $value)",
    "body": ".setEssentialClientRule($ruleName, $value)",
    "description": "<MinecraftClient>.setEssentialClientRule(ruleName, value)\nThis sets the given client rule to the given value.\nThis may throw an error if the name is invalid or the rule cannot be set.\n- Parameter - String (`ruleName`): The client rule.\n- Parameter - Object (`value`): The new value for the rule.\n"
  },
  "Method <MinecraftClient>.stripFormatting(string)": {
    "prefix": ".stripFormatting($string)",
    "body": ".stripFormatting($string)",
    "description": "<MinecraftClient>.stripFormatting(string)\nThis strips the formatting from the given string.\n- Parameter - String (`string`): The string to strip.\n"
  },
  "Method <MinecraftClient>.syncToTick()": {
    "prefix": ".syncToTick()",
    "body": ".syncToTick()",
    "description": "<MinecraftClient>.syncToTick()\nSynchronizes the current thread in Arucas to the next game tick.\n"
  },
  "Method <MinecraftClient>.tick()": {
    "prefix": ".tick()",
    "body": ".tick()",
    "description": "<MinecraftClient>.tick()\nThis ticks the client.\n"
  },
  "Method <MinecraftClient>.uuidFromPlayerName(name)": {
    "prefix": ".uuidFromPlayerName($name)",
    "body": ".uuidFromPlayerName($name)",
    "description": "<MinecraftClient>.uuidFromPlayerName(name)\nThis will return the uuid from the given player name.\nThe player uuid is fetched from the Mojang API, this is\nintended for use to get a player's uuid who is not online.\n- Parameter - String (`name`): The player name.\n"
  },
  "Static Method MinecraftClient.get()": {
    "prefix": "MinecraftClient.get()",
    "body": "MinecraftClient.get()",
    "description": "MinecraftClient.get()\nReturns the MinecraftClient instance.\n"
  },
  "Static Method MinecraftClient.getClient()": {
    "prefix": "MinecraftClient.getClient()",
    "body": "MinecraftClient.getClient()",
    "description": "MinecraftClient.getClient()\nReturns the MinecraftClient instance.\n"
  },
  "MinecraftTask Class": {
    "prefix": "MinecraftTask",
    "body": "MinecraftTask",
    "description": "The MinecraftTask class from Minecraft.\nThis class is used to create tasks that can be chained and\nrun on the main Minecraft thread. This ensures that all\nbehaviors work as intended.\n"
  },
  "Constructor new MinecraftTask()": {
    "prefix": "new MinecraftTask()",
    "body": "new MinecraftTask()",
    "description": "new MinecraftTask()\nThis creates a new empty Minecraft task.\n"
  },
  "Method <MinecraftTask>.run()": {
    "prefix": ".run()",
    "body": ".run()",
    "description": "<MinecraftTask>.run()\nThis runs the task on the main Minecraft thread. It returns a future\nwhich can be awaited, the last function in the chain will be used as\nthe return value for the future.\n"
  },
  "Method <MinecraftTask>.waitThen(ticks, function)": {
    "prefix": ".waitThen($ticks, $function)",
    "body": ".waitThen($ticks, $function)",
    "description": "<MinecraftTask>.waitThen(ticks, function)\nThis adds a delay (in ticks) then runs the given task.\nThis delay is will also affect all following chained function\ndelays. If this is the last function in the chain, then the\nreturn value will be determined by this function.\n- Parameter - Number (`ticks`): The amount of ticks delay before the function runs.\n- Parameter - Function (`function`): The function to run after the delay.\n"
  },
  "Network Class": {
    "prefix": "Network",
    "body": "Network",
    "description": "The Network class.\nAllows you to do http requests. This is a utility class and cannot be constructed.\n"
  },
  "Static Method Network.downloadFile(url, file)": {
    "prefix": "Network.downloadFile(url, file)",
    "body": "Network.downloadFile($url, $file)",
    "description": "Network.downloadFile(url, file)\nDownloads a file from an url to a file.\n- Parameter - String (`url`): The url to download from.\n- Parameter - File (`file`): The file to download to.\n"
  },
  "Static Method Network.openUrl(url)": {
    "prefix": "Network.openUrl(url)",
    "body": "Network.openUrl($url)",
    "description": "Network.openUrl(url)\nOpens an url in the default browser.\n- Parameter - String (`url`): The url to open.\n"
  },
  "Static Method Network.requestUrl(url)": {
    "prefix": "Network.requestUrl(url)",
    "body": "Network.requestUrl($url)",
    "description": "Network.requestUrl(url)\nRequests an url and returns the response.\n- Parameter - String (`url`): The url to request.\n"
  },
  "Null Class": {
    "prefix": "Null",
    "body": "Null",
    "description": "The Null class.\nThis class is used for the null object,\nthis cannot be instantiated or extended.\n"
  },
  "Number Class": {
    "prefix": "Number",
    "body": "Number",
    "description": "The Number class.\nThis class cannot be constructed as it has a literal representation.\nFor math related functions see the Math class.\n"
  },
  "Method <Number>.ceil()": {
    "prefix": ".ceil()",
    "body": ".ceil()",
    "description": "<Number>.ceil()\nThis allows you to round a number up to the nearest integer.\n"
  },
  "Method <Number>.floor()": {
    "prefix": ".floor()",
    "body": ".floor()",
    "description": "<Number>.floor()\nThis allows you to round a number down to the nearest integer.\n"
  },
  "Method <Number>.isInfinite()": {
    "prefix": ".isInfinite()",
    "body": ".isInfinite()",
    "description": "<Number>.isInfinite()\nThis allows you to check if a number is infinite.\n"
  },
  "Method <Number>.isNaN()": {
    "prefix": ".isNaN()",
    "body": ".isNaN()",
    "description": "<Number>.isNaN()\nThis allows you to check if a number is not a number.\n"
  },
  "Method <Number>.round()": {
    "prefix": ".round()",
    "body": ".round()",
    "description": "<Number>.round()\nThis allows you to round a number to the nearest integer.\n"
  },
  "Object Class": {
    "prefix": "Object",
    "body": "Object",
    "description": "The Object class.\nThis is the base class for every other class in Arucas.\nThis class cannot be instantiated from, you can extend it\nhowever every class already extends this class by default.\n"
  },
  "Method <Object>.copy()": {
    "prefix": ".copy()",
    "body": ".copy()",
    "description": "<Object>.copy()\nThis returns a copy of the value if implemented.\nSome objects that are immutable, such as Strings and Numbers\nwill not be copied, and will return the same instance.\nAny object that has not implemented the copy method will also\nreturn the same instance.\n"
  },
  "Method <Object>.hashCode()": {
    "prefix": ".hashCode()",
    "body": ".hashCode()",
    "description": "<Object>.hashCode()\nThis returns the hash code of the value, mainly used for maps and sets\nthe hash code of an object must remain consistent for objects to be able\nto be used as keys in a map or set. If two objects are equal, they must\nhave the same hash code.\n"
  },
  "Method <Object>.instanceOf(type)": {
    "prefix": ".instanceOf($type)",
    "body": ".instanceOf($type)",
    "description": "<Object>.instanceOf(type)\nThis returns true if the value is an instance of the given type.\n- Parameter - Type (`type`): The type to check against.\n"
  },
  "Method <Object>.toString()": {
    "prefix": ".toString()",
    "body": ".toString()",
    "description": "<Object>.toString()\nThis returns the string representation of the value.\n"
  },
  "Method <Object>.uniqueHash()": {
    "prefix": ".uniqueHash()",
    "body": ".uniqueHash()",
    "description": "<Object>.uniqueHash()\nThis returns the unique hash of the value, this is different for every instance of a value.\n"
  },
  "OtherPlayer Class": {
    "prefix": "OtherPlayer",
    "body": "OtherPlayer",
    "description": "The OtherPlayer class from Minecraft.\nThis class is used to represent all players, mainly other players,\nthis class extends LivingEntity and so inherits all of their methods too.\n"
  },
  "Method <OtherPlayer>.getAbilities()": {
    "prefix": ".getAbilities()",
    "body": ".getAbilities()",
    "description": "<OtherPlayer>.getAbilities()\nThis gets the abilities of the player in a map\nFor example:\n`{\"invulnerable\": false, \"canFly\": true, \"canBreakBlocks\": true, \"isCreative\": true, \"walkSpeed\": 1.0, \"flySpeed\": 1.2}`.\n"
  },
  "Method <OtherPlayer>.getAllSlotsFor(materialLike)": {
    "prefix": ".getAllSlotsFor($materialLike)",
    "body": ".getAllSlotsFor($materialLike)",
    "description": "<OtherPlayer>.getAllSlotsFor(materialLike)\nThis gets all the slot numbers of the specified item in the players combined inventory.\n- Parameter - Material (`materialLike`): The item or material you want to get the slot of.\n"
  },
  "Method <OtherPlayer>.getAllSlotsFor(materialLike, inventoryType)": {
    "prefix": ".getAllSlotsFor($materialLike, $inventoryType)",
    "body": ".getAllSlotsFor($materialLike, $inventoryType)",
    "description": "<OtherPlayer>.getAllSlotsFor(materialLike, inventoryType)\nThis gets all the slot numbers of the specified item in the players combined inventory.\n- Parameter - Material (`materialLike`): The item or material you want to get the slot of.\n- Parameter - String (`inventoryType`): All/combined -> includes external, player/main -> player slots, external/other -> excludes player inventory.\n"
  },
  "Method <OtherPlayer>.getCurrentSlot()": {
    "prefix": ".getCurrentSlot()",
    "body": ".getCurrentSlot()",
    "description": "<OtherPlayer>.getCurrentSlot()\nThis gets the players currently selected slot.\n"
  },
  "Method <OtherPlayer>.getEmptySlots()": {
    "prefix": ".getEmptySlots()",
    "body": ".getEmptySlots()",
    "description": "<OtherPlayer>.getEmptySlots()\nThis gets all the empty slots in the player inventory.\n"
  },
  "Method <OtherPlayer>.getFishingBobber()": {
    "prefix": ".getFishingBobber()",
    "body": ".getFishingBobber()",
    "description": "<OtherPlayer>.getFishingBobber()\nThis gets the fishing bobber that the player has.\n"
  },
  "Method <OtherPlayer>.getGamemode()": {
    "prefix": ".getGamemode()",
    "body": ".getGamemode()",
    "description": "<OtherPlayer>.getGamemode()\nThis gets the players gamemode, may be null if not known.\n"
  },
  "Method <OtherPlayer>.getHeldItem()": {
    "prefix": ".getHeldItem()",
    "body": ".getHeldItem()",
    "description": "<OtherPlayer>.getHeldItem()\nThis gets the players currently selected item, in their main hand.\n"
  },
  "Method <OtherPlayer>.getHunger()": {
    "prefix": ".getHunger()",
    "body": ".getHunger()",
    "description": "<OtherPlayer>.getHunger()\nThis gets the hunger level of the player.\n"
  },
  "Method <OtherPlayer>.getItemForPlayerSlot(slotNum)": {
    "prefix": ".getItemForPlayerSlot($slotNum)",
    "body": ".getItemForPlayerSlot($slotNum)",
    "description": "<OtherPlayer>.getItemForPlayerSlot(slotNum)\nThis gets the item in the specified slot, in the players inventory, not including inventories of open containers.\nThis will throw an error if the slot is out of bounds.\n- Parameter - Number (`slotNum`): The slot number you want to get.\n"
  },
  "Method <OtherPlayer>.getItemForSlot(slotNum)": {
    "prefix": ".getItemForSlot($slotNum)",
    "body": ".getItemForSlot($slotNum)",
    "description": "<OtherPlayer>.getItemForSlot(slotNum)\nThis gets the item in the specified slot, in the total players inventory, including inventories of open containers.\nThis will throw an error if the index is out of bounds.\n- Parameter - Number (`slotNum`): The slot number you want to get.\n"
  },
  "Method <OtherPlayer>.getLevels()": {
    "prefix": ".getLevels()",
    "body": ".getLevels()",
    "description": "<OtherPlayer>.getLevels()\nThis gets the number of experience levels the player has.\n"
  },
  "Method <OtherPlayer>.getNextLevelExperience()": {
    "prefix": ".getNextLevelExperience()",
    "body": ".getNextLevelExperience()",
    "description": "<OtherPlayer>.getNextLevelExperience()\nThis gets the number of experience required to level up for the player.\n"
  },
  "Method <OtherPlayer>.getPlayerName()": {
    "prefix": ".getPlayerName()",
    "body": ".getPlayerName()",
    "description": "<OtherPlayer>.getPlayerName()\nThis gets the players name.\n"
  },
  "Method <OtherPlayer>.getSaturation()": {
    "prefix": ".getSaturation()",
    "body": ".getSaturation()",
    "description": "<OtherPlayer>.getSaturation()\nThis gets the saturation level of the player.\n"
  },
  "Method <OtherPlayer>.getSlotFor(materialLike)": {
    "prefix": ".getSlotFor($materialLike)",
    "body": ".getSlotFor($materialLike)",
    "description": "<OtherPlayer>.getSlotFor(materialLike)\nThis gets the slot number of the specified item in the players combined inventory.\n- Parameter - Material (`materialLike`): The item or material you want to get the slot of.\n"
  },
  "Method <OtherPlayer>.getTotalSlots()": {
    "prefix": ".getTotalSlots()",
    "body": ".getTotalSlots()",
    "description": "<OtherPlayer>.getTotalSlots()\nThis gets the players total inventory slots.\n"
  },
  "Method <OtherPlayer>.getXpProgress()": {
    "prefix": ".getXpProgress()",
    "body": ".getXpProgress()",
    "description": "<OtherPlayer>.getXpProgress()\nThis gets the number of experience progress the player has.\n"
  },
  "Method <OtherPlayer>.isInventoryFull()": {
    "prefix": ".isInventoryFull()",
    "body": ".isInventoryFull()",
    "description": "<OtherPlayer>.isInventoryFull()\nThis gets whether the players inventory is full.\nMore specifically whether the player has no empty slots.\n"
  },
  "Method <OtherPlayer>.isPlayerSlot(slotNum)": {
    "prefix": ".isPlayerSlot($slotNum)",
    "body": ".isPlayerSlot($slotNum)",
    "description": "<OtherPlayer>.isPlayerSlot(slotNum)\nThis gets inventory type (player / other) for given slot numbers.\nThis will throw an error if the index is out of bounds.\n- Parameter - Number (`slotNum`): The slot number you want to get.\n"
  },
  "OutlinedShape Class": {
    "prefix": "OutlinedShape",
    "body": "OutlinedShape",
    "description": "The OutlinedShape class from Minecraft.\nThis class represents all shapes that can be outlined.\n"
  },
  "Method <OutlinedShape>.getOutlineBlue()": {
    "prefix": ".getOutlineBlue()",
    "body": ".getOutlineBlue()",
    "description": "<OutlinedShape>.getOutlineBlue()\nThis gets the outline blue value of the shape.\n"
  },
  "Method <OutlinedShape>.getOutlineGreen()": {
    "prefix": ".getOutlineGreen()",
    "body": ".getOutlineGreen()",
    "description": "<OutlinedShape>.getOutlineGreen()\nThis gets the outline green value of the shape.\n"
  },
  "Method <OutlinedShape>.getOutlineRed()": {
    "prefix": ".getOutlineRed()",
    "body": ".getOutlineRed()",
    "description": "<OutlinedShape>.getOutlineRed()\nThis gets the outline red value of the shape.\n"
  },
  "Method <OutlinedShape>.getOutlineWidth()": {
    "prefix": ".getOutlineWidth()",
    "body": ".getOutlineWidth()",
    "description": "<OutlinedShape>.getOutlineWidth()\nThis gets the outline width of the shape.\n"
  },
  "Method <OutlinedShape>.setOutlineBlue(blue)": {
    "prefix": ".setOutlineBlue($blue)",
    "body": ".setOutlineBlue($blue)",
    "description": "<OutlinedShape>.setOutlineBlue(blue)\nThis sets the outline blue value of the shape, using a single value.\n- Parameter - Number (`blue`): The amount of blue between 0 - 255.\n"
  },
  "Method <OutlinedShape>.setOutlineColour(colour)": {
    "prefix": ".setOutlineColour($colour)",
    "body": ".setOutlineColour($colour)",
    "description": "<OutlinedShape>.setOutlineColour(colour)\nThis sets the width of the shape, using a single value, this function\nalso has a sibling named `setOutlineColor()` that has the same functionality.\nThe colour generally should be hexadecimal in the form 0xRRGGBB.\n- Parameter - Number (`colour`): The colour you want to set.\n"
  },
  "Method <OutlinedShape>.setOutlineColour(red, green, blue)": {
    "prefix": ".setOutlineColour($red, $green, $blue)",
    "body": ".setOutlineColour($red, $green, $blue)",
    "description": "<OutlinedShape>.setOutlineColour(red, green, blue)\nThis sets the outline colour of the shape, using three values, this function\nalso has a sibling named `setOutlineColor()` that has the same functionality.\nIf the colours are not between 0 and 255 an error will be thrown.\n- Parameter - Number (`red`): The amount of red 0 - 255.\n- Parameter - Number (`green`): The amount of green 0 - 255.\n- Parameter - Number (`blue`): The amount of blue 0 - 255.\n"
  },
  "Method <OutlinedShape>.setOutlineGreen(green)": {
    "prefix": ".setOutlineGreen($green)",
    "body": ".setOutlineGreen($green)",
    "description": "<OutlinedShape>.setOutlineGreen(green)\nThis sets the outline green value of the shape, using a single value.\n- Parameter - Number (`green`): The amount of green between 0 - 255.\n"
  },
  "Method <OutlinedShape>.setOutlineRed(red)": {
    "prefix": ".setOutlineRed($red)",
    "body": ".setOutlineRed($red)",
    "description": "<OutlinedShape>.setOutlineRed(red)\nThis sets the outline red value of the shape, using a single value.\n- Parameter - Number (`red`): The amount of red between 0 - 255.\n"
  },
  "Method <OutlinedShape>.setOutlineWidth(width)": {
    "prefix": ".setOutlineWidth($width)",
    "body": ".setOutlineWidth($width)",
    "description": "<OutlinedShape>.setOutlineWidth(width)\nThis sets the outline width of the shape, this should not be negative.\n- Parameter - Number (`width`): The width of the outline.\n"
  },
  "Player Class": {
    "prefix": "Player",
    "body": "Player",
    "description": "The Player class from Minecraft.\nThis class is used to interact with the main player, this extends OtherPlayer\nand so inherits all methods from that class.\n"
  },
  "Method <Player>.anvil(predicate1, predicate2)": {
    "prefix": ".anvil($predicate1, $predicate2)",
    "body": ".anvil($predicate1, $predicate2)",
    "description": "<Player>.anvil(predicate1, predicate2)\nThis allows you to combine two items in an anvil.\n- Parameter - Function (`predicate1`): A function determining whether the first ItemStack meets a criteria.\n- Parameter - Function (`predicate2`): A function determining whether the second ItemStack meets a criteria.\n"
  },
  "Method <Player>.anvil(predicate1, predicate2, take)": {
    "prefix": ".anvil($predicate1, $predicate2, $take)",
    "body": ".anvil($predicate1, $predicate2, $take)",
    "description": "<Player>.anvil(predicate1, predicate2, take)\nThis allows you to combine two items in an anvil.\n- Parameter - Function (`predicate1`): A function determining whether the first ItemStack meets a criteria.\n- Parameter - Function (`predicate2`): A function determining whether the second ItemStack meets a criteria.\n- Parameter - Boolean (`take`): Whether you should take the item after putting items in the anvil.\n"
  },
  "Method <Player>.anvilRename(name, predicate)": {
    "prefix": ".anvilRename($name, $predicate)",
    "body": ".anvilRename($name, $predicate)",
    "description": "<Player>.anvilRename(name, predicate)\nThis allows you to name an item in an anvil.\n- Parameter - String (`name`): The name you want to give the item.\n- Parameter - Function (`predicate`): Whether the ItemStack meets a certain criteria.\n"
  },
  "Method <Player>.attack(action)": {
    "prefix": ".attack($action)",
    "body": ".attack($action)",
    "description": "<Player>.attack(action)\nThis allows you to make your player attack, you must\npass 'hold', 'stop', or 'once' otherwise an error will be thrown.\n- Parameter - String (`action`): The type of action, either 'hold', 'stop', or 'once'.\n"
  },
  "Method <Player>.attackBlock(pos, direction)": {
    "prefix": ".attackBlock($pos, $direction)",
    "body": ".attackBlock($pos, $direction)",
    "description": "<Player>.attackBlock(pos, direction)\nThis allows you to attack a block at a position and direction.\n- Parameter - Pos (`pos`): The position of the block.\n- Parameter - String (`direction`): The direction of the attack, e.g. 'up', 'north', 'east', etc.\n"
  },
  "Method <Player>.attackBlock(x, y, z, direction)": {
    "prefix": ".attackBlock($x, $y, $z, $direction)",
    "body": ".attackBlock($x, $y, $z, $direction)",
    "description": "<Player>.attackBlock(x, y, z, direction)\nThis allows you to attack a block at a position and direction.\n- Parameter - Number (`x`): The x position.\n- Parameter - Number (`y`): The y position.\n- Parameter - Number (`z`): The z position.\n- Parameter - String (`direction`): The direction of the attack, e.g. 'up', 'north', 'east', etc.\n"
  },
  "Method <Player>.attackEntity(entity)": {
    "prefix": ".attackEntity($entity)",
    "body": ".attackEntity($entity)",
    "description": "<Player>.attackEntity(entity)\nThis makes your player attack an entity without\nhaving to be looking at it or clicking on the entity.\n- Parameter - Entity (`entity`): The entity to attack.\n"
  },
  "Method <Player>.breakBlock(pos)": {
    "prefix": ".breakBlock($pos)",
    "body": ".breakBlock($pos)",
    "description": "<Player>.breakBlock(pos)\nThis breaks a block at a given position, if it is able to be broken.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <Player>.canPlaceBlockAt(block, pos)": {
    "prefix": ".canPlaceBlockAt($block, $pos)",
    "body": ".canPlaceBlockAt($block, $pos)",
    "description": "<Player>.canPlaceBlockAt(block, pos)\nChecks block can be placed at given position.\n- Parameter - Block (`block`): The block to check for.\n- Parameter - Pos (`pos`): The position to check.\n"
  },
  "Method <Player>.canPlaceBlockAt(block, x, y, z)": {
    "prefix": ".canPlaceBlockAt($block, $x, $y, $z)",
    "body": ".canPlaceBlockAt($block, $x, $y, $z)",
    "description": "<Player>.canPlaceBlockAt(block, x, y, z)\nChecks block can be placed at given position.\n- Parameter - Block (`block`): The block to check for.\n- Parameter - Number (`x`): The x coordinate of the position.\n- Parameter - Number (`y`): The y coordinate of the position.\n- Parameter - Number (`z`): The z coordinate of the position.\n"
  },
  "Method <Player>.clickCreativeStack(itemStack, slot)": {
    "prefix": ".clickCreativeStack($itemStack, $slot)",
    "body": ".clickCreativeStack($itemStack, $slot)",
    "description": "<Player>.clickCreativeStack(itemStack, slot)\nThis allows you to click Creative stack, but requires sync with server.\n- Parameter - ItemStack (`itemStack`): Stack to click.\n- Parameter - Number (`slot`): The slot to click.\n"
  },
  "Method <Player>.clickRecipe(recipe)": {
    "prefix": ".clickRecipe($recipe)",
    "body": ".clickRecipe($recipe)",
    "description": "<Player>.clickRecipe(recipe)\nThis allows you to click a predefined recipe.\n- Parameter - Recipe (`recipe`): The recipe you want to select.\n"
  },
  "Method <Player>.clickRecipe(recipe, boolean)": {
    "prefix": ".clickRecipe($recipe, $boolean)",
    "body": ".clickRecipe($recipe, $boolean)",
    "description": "<Player>.clickRecipe(recipe, boolean)\nThis allows you to click a predefined recipe.\n- Parameter - Recipe (`recipe`): The recipe you want to select.\n- Parameter - Boolean (`boolean`): Whether to shift click the recipe.\n"
  },
  "Method <Player>.clickSlot(slot, click, action)": {
    "prefix": ".clickSlot($slot, $click, $action)",
    "body": ".clickSlot($slot, $click, $action)",
    "description": "<Player>.clickSlot(slot, click, action)\nThis allows you to click a slot with either right or left click\nand a slot action, the click must be either 'left' or 'right' or a number (for swap).\nThe action must be either 'click', 'shift_click', 'swap', 'middle_click',\n'throw', 'drag', or 'double_click' or an error will be thrown.\n- Parameter - Number (`slot`): The slot to click.\n- Parameter - String (`click`): The click type, this should be either 'left' or 'right'.\n- Parameter - String (`action`): The action to perform.\n"
  },
  "Method <Player>.closeScreen()": {
    "prefix": ".closeScreen()",
    "body": ".closeScreen()",
    "description": "<Player>.closeScreen()\nThis closes the current screen.\n"
  },
  "Method <Player>.craft(recipe)": {
    "prefix": ".craft($recipe)",
    "body": ".craft($recipe)",
    "description": "<Player>.craft(recipe)\nThis allows you to craft a recipe, this can be 2x2 or 3x3\nThe list you pass in must contain Materials or ItemStacks\nMost of the time you should use craftRecipe instead. You must\nbe in an appropriate gui for the crafting recipe or an error will be thrown.\n- Parameter - List (`recipe`): A list of materials making up the recipe you want to craft including air.\n"
  },
  "Method <Player>.craftRecipe(recipe)": {
    "prefix": ".craftRecipe($recipe)",
    "body": ".craftRecipe($recipe)",
    "description": "<Player>.craftRecipe(recipe)\nThis allows you to craft a predefined recipe.\n- Parameter - Recipe (`recipe`): The recipe you want to craft.\n"
  },
  "Method <Player>.craftRecipe(recipe, boolean)": {
    "prefix": ".craftRecipe($recipe, $boolean)",
    "body": ".craftRecipe($recipe, $boolean)",
    "description": "<Player>.craftRecipe(recipe, boolean)\nThis allows you to craft a predefined recipe.\n- Parameter - Recipe (`recipe`): The recipe you want to craft.\n- Parameter - Boolean (`boolean`): Whether result should be dropped or not.\n"
  },
  "Method <Player>.dropAll(material)": {
    "prefix": ".dropAll($material)",
    "body": ".dropAll($material)",
    "description": "<Player>.dropAll(material)\nThis drops all items of a given type in the player's inventory.\n- Parameter - Material (`material`): The item stack, or material type to drop.\n"
  },
  "Method <Player>.dropAllExact(itemStack)": {
    "prefix": ".dropAllExact($itemStack)",
    "body": ".dropAllExact($itemStack)",
    "description": "<Player>.dropAllExact(itemStack)\nThis drops all the items that have the same nbt as a given stack.\n- Parameter - ItemStack (`itemStack`): The stack with nbt to drop.\n"
  },
  "Method <Player>.dropItemInHand(dropAll)": {
    "prefix": ".dropItemInHand($dropAll)",
    "body": ".dropItemInHand($dropAll)",
    "description": "<Player>.dropItemInHand(dropAll)\nThis drops the item(s) in the player's main hand.\n- Parameter - Boolean (`dropAll`): If true, all items in the player's main hand will be dropped.\n"
  },
  "Method <Player>.dropSlot(slot)": {
    "prefix": ".dropSlot($slot)",
    "body": ".dropSlot($slot)",
    "description": "<Player>.dropSlot(slot)\nThis allows you to drop the items in a slot.\n- Parameter - Number (`slot`): The slot to drop.\n"
  },
  "Method <Player>.fakeLook(yaw, pitch, direction, duration)": {
    "prefix": ".fakeLook($yaw, $pitch, $direction, $duration)",
    "body": ".fakeLook($yaw, $pitch, $direction, $duration)",
    "description": "<Player>.fakeLook(yaw, pitch, direction, duration)\nThis makes the player 'fake' looking in a direction, this can be\nused to place blocks in unusual orientations without moving the camera.\n- Parameter - Number (`yaw`): The yaw to look at.\n- Parameter - Number (`pitch`): The pitch to look at.\n- Parameter - String (`direction`): The direction to look at.\n- Parameter - Number (`duration`): The duration of the look in ticks.\n"
  },
  "Method <Player>.getBlockBreakingSpeed(itemStack, block)": {
    "prefix": ".getBlockBreakingSpeed($itemStack, $block)",
    "body": ".getBlockBreakingSpeed($itemStack, $block)",
    "description": "<Player>.getBlockBreakingSpeed(itemStack, block)\nThis returns the block breaking speed of the player on a block including enchanements and effects.\n- Parameter - ItemStack (`itemStack`): Item to test with.\n- Parameter - Block (`block`): The block to get the speed of.\n"
  },
  "Method <Player>.getCurrentScreen()": {
    "prefix": ".getCurrentScreen()",
    "body": ".getCurrentScreen()",
    "description": "<Player>.getCurrentScreen()\nThis gets the current screen the player is in.\n"
  },
  "Method <Player>.getLookingAtEntity()": {
    "prefix": ".getLookingAtEntity()",
    "body": ".getLookingAtEntity()",
    "description": "<Player>.getLookingAtEntity()\nThis gets the entity that the player is currently looking at.\n"
  },
  "Method <Player>.getSelectedSlot()": {
    "prefix": ".getSelectedSlot()",
    "body": ".getSelectedSlot()",
    "description": "<Player>.getSelectedSlot()\nThis gets the current selected slot number your player is holding.\n"
  },
  "Method <Player>.getSwappableHotbarSlot()": {
    "prefix": ".getSwappableHotbarSlot()",
    "body": ".getSwappableHotbarSlot()",
    "description": "<Player>.getSwappableHotbarSlot()\nThis will get the next empty slot in the hotbar starting from the current slot\ngoing right, and if it reaches the end of the hotbar it will start from the beginning.\nIf there is no empty slot it will return any slot that doesn't have an item with\nan enchantment that is in the hotbar, again going from the current slot\nif there is no such slot it will return the current selected slot.\n"
  },
  "Method <Player>.interactBlock(pos, direction)": {
    "prefix": ".interactBlock($pos, $direction)",
    "body": ".interactBlock($pos, $direction)",
    "description": "<Player>.interactBlock(pos, direction)\nThis allows you to interact with a block at a position and direction.\n- Parameter - Pos (`pos`): The position of the block.\n- Parameter - String (`direction`): The direction of the interaction, e.g. 'up', 'north', 'east', etc.\n"
  },
  "Method <Player>.interactBlock(pos, direction, hand)": {
    "prefix": ".interactBlock($pos, $direction, $hand)",
    "body": ".interactBlock($pos, $direction, $hand)",
    "description": "<Player>.interactBlock(pos, direction, hand)\nThis allows you to interact with a block at a position, direction, and hand.\n- Parameter - Pos (`pos`): The position of the block.\n- Parameter - String (`direction`): The direction of the interaction, e.g. 'up', 'north', 'east', etc.\n- Parameter - String (`hand`): The hand to use, e.g. 'main_hand', 'off_hand'.\n"
  },
  "Method <Player>.interactBlock(pos, direction, blockPos, insideBlock)": {
    "prefix": ".interactBlock($pos, $direction, $blockPos, $insideBlock)",
    "body": ".interactBlock($pos, $direction, $blockPos, $insideBlock)",
    "description": "<Player>.interactBlock(pos, direction, blockPos, insideBlock)\nThis allows you to interact with a block at a position and direction\nThis function is for very specific cases where there needs to be extra precision\nlike when placing stairs or slabs in certain directions, so the first set of\ncoords is the exact position of the block, and the second set of coords is the position.\n- Parameter - Pos (`pos`): The exact position of the block.\n- Parameter - String (`direction`): The direction of the interaction, e.g. 'up', 'north', 'east', etc.\n- Parameter - Pos (`blockPos`): The position of the block.\n- Parameter - Boolean (`insideBlock`): Whether the player is inside the block.\n"
  },
  "Method <Player>.interactBlock(pos, direction, hand, blockPos, insideBlock)": {
    "prefix": ".interactBlock($pos, $direction, $hand, $blockPos, $insideBlock)",
    "body": ".interactBlock($pos, $direction, $hand, $blockPos, $insideBlock)",
    "description": "<Player>.interactBlock(pos, direction, hand, blockPos, insideBlock)\nThis allows you to interact with a block at a position and direction\nThis function is for very specific cases where there needs to be extra precision\nlike when placing stairs or slabs in certain directions, so the first set of\ncoords is the exact position of the block, and the second set of coords is the position.\n- Parameter - Pos (`pos`): The exact position of the block.\n- Parameter - String (`direction`): The direction of the interaction, e.g. 'up', 'north', 'east', etc.\n- Parameter - String (`hand`): The hand to use, e.g. 'main_hand', 'off_hand'.\n- Parameter - Pos (`blockPos`): The position of the block.\n- Parameter - Boolean (`insideBlock`): Whether the player is inside the block.\n"
  },
  "Method <Player>.interactBlock(x, y, z, direction, blockX, blockY, blockZ, insideBlock)": {
    "prefix": ".interactBlock($x, $y, $z, $direction, $blockX, $blockY, $blockZ, $insideBlock)",
    "body": ".interactBlock($x, $y, $z, $direction, $blockX, $blockY, $blockZ, $insideBlock)",
    "description": "<Player>.interactBlock(x, y, z, direction, blockX, blockY, blockZ, insideBlock)\nThis allows you to interact with a block at a position and direction\nThis function is for very specific cases where there needs to be extra precision\nlike when placing stairs or slabs in certain directions, so the first set of\ncoords is the exact position of the block, and the second set of coords is the position.\n- Parameter - Number (`x`): The exact x position.\n- Parameter - Number (`y`): The exact y position.\n- Parameter - Number (`z`): The exact z position.\n- Parameter - String (`direction`): The direction of the interaction, e.g. 'up', 'north', 'east', etc.\n- Parameter - Number (`blockX`): The x position of the block.\n- Parameter - Number (`blockY`): The y position of the block.\n- Parameter - Number (`blockZ`): The z position of the block.\n- Parameter - Boolean (`insideBlock`): Whether the player is inside the block.\n"
  },
  "Method <Player>.interactItem(hand)": {
    "prefix": ".interactItem($hand)",
    "body": ".interactItem($hand)",
    "description": "<Player>.interactItem(hand)\nThis allows you to interact item with given Hand.\n- Parameter - String (`hand`):  Hand to use, either 'main' or 'offhand'.\n"
  },
  "Method <Player>.interactWithEntity(entity)": {
    "prefix": ".interactWithEntity($entity)",
    "body": ".interactWithEntity($entity)",
    "description": "<Player>.interactWithEntity(entity)\nThis allows your player to interact with an entity without\nhaving to be looking at it or clicking on the entity.\n- Parameter - Entity (`entity`): The entity to interact with.\n"
  },
  "Method <Player>.jump()": {
    "prefix": ".jump()",
    "body": ".jump()",
    "description": "<Player>.jump()\nThis will make the player jump if they are on the ground.\n"
  },
  "Method <Player>.logout(message)": {
    "prefix": ".logout($message)",
    "body": ".logout($message)",
    "description": "<Player>.logout(message)\nThis forces the player to leave the world.\n- Parameter - String (`message`): The message to display to the player on the logout screen.\n"
  },
  "Method <Player>.look(yaw, pitch)": {
    "prefix": ".look($yaw, $pitch)",
    "body": ".look($yaw, $pitch)",
    "description": "<Player>.look(yaw, pitch)\nThis sets the player's look direction.\n- Parameter - Number (`yaw`): The yaw of the player's look direction.\n- Parameter - Number (`pitch`): The pitch of the player's look direction.\n"
  },
  "Method <Player>.lookAtPos(pos)": {
    "prefix": ".lookAtPos($pos)",
    "body": ".lookAtPos($pos)",
    "description": "<Player>.lookAtPos(pos)\nThis makes your player look towards a position.\n- Parameter - Pos (`pos`): The position to look at.\n"
  },
  "Method <Player>.lookAtPos(x, y, z)": {
    "prefix": ".lookAtPos($x, $y, $z)",
    "body": ".lookAtPos($x, $y, $z)",
    "description": "<Player>.lookAtPos(x, y, z)\nThis makes your player look towards a position.\n- Parameter - Number (`x`): The x coordinate of the position.\n- Parameter - Number (`y`): The y coordinate of the position.\n- Parameter - Number (`z`): The z coordinate of the position.\n"
  },
  "Method <Player>.message(message)": {
    "prefix": ".message($message)",
    "body": ".message($message)",
    "description": "<Player>.message(message)\nThis allows you to send a message to your player, only they will see this, purely client side.\n- Parameter - Text (`message`): The message to send, can also be string.\n"
  },
  "Method <Player>.messageActionBar(message)": {
    "prefix": ".messageActionBar($message)",
    "body": ".messageActionBar($message)",
    "description": "<Player>.messageActionBar(message)\nThis allows you to set the current memssage displaying on the action bar.\n- Parameter - Text (`message`): The message to send, can also be string.\n"
  },
  "Method <Player>.openInventory()": {
    "prefix": ".openInventory()",
    "body": ".openInventory()",
    "description": "<Player>.openInventory()\nThis opens the player's inventory.\n"
  },
  "Method <Player>.openScreen(screen)": {
    "prefix": ".openScreen($screen)",
    "body": ".openScreen($screen)",
    "description": "<Player>.openScreen(screen)\nThis opens a screen for the player, this cannot open server side screens.\nThis will throw an error if you are trying to open a handled screen.\n- Parameter - Screen (`screen`): The screen to open.\n"
  },
  "Method <Player>.say(message)": {
    "prefix": ".say($message)",
    "body": ".say($message)",
    "description": "<Player>.say(message)\nThis allows you to make your player send a message in chat, this includes commands.\n- Parameter - String (`message`): The message to send.\n"
  },
  "Method <Player>.setSelectedSlot(slot)": {
    "prefix": ".setSelectedSlot($slot)",
    "body": ".setSelectedSlot($slot)",
    "description": "<Player>.setSelectedSlot(slot)\nThis allows you to set the slot number your player is holding.\nIf the number is not between 0 and 8 an error will be thrown.\n- Parameter - Number (`slot`): The slot number, must be between 0 - 8.\n"
  },
  "Method <Player>.setSneaking(sneaking)": {
    "prefix": ".setSneaking($sneaking)",
    "body": ".setSneaking($sneaking)",
    "description": "<Player>.setSneaking(sneaking)\nThis sets the player's sneaking state.\n- Parameter - Boolean (`sneaking`): The sneaking state.\n"
  },
  "Method <Player>.setSprinting(sprinting)": {
    "prefix": ".setSprinting($sprinting)",
    "body": ".setSprinting($sprinting)",
    "description": "<Player>.setSprinting(sprinting)\nThis sets the player's sprinting state.\n- Parameter - Boolean (`sprinting`): The sprinting state.\n"
  },
  "Method <Player>.setWalking(walking)": {
    "prefix": ".setWalking($walking)",
    "body": ".setWalking($walking)",
    "description": "<Player>.setWalking(walking)\nThis sets the player's walking state.\n- Parameter - Boolean (`walking`): The walking state.\n"
  },
  "Method <Player>.shiftClickSlot(slot)": {
    "prefix": ".shiftClickSlot($slot)",
    "body": ".shiftClickSlot($slot)",
    "description": "<Player>.shiftClickSlot(slot)\nThis allows you to shift click a slot.\n- Parameter - Number (`slot`): The slot to click.\n"
  },
  "Method <Player>.showTitle(title, subtitle)": {
    "prefix": ".showTitle($title, $subtitle)",
    "body": ".showTitle($title, $subtitle)",
    "description": "<Player>.showTitle(title, subtitle)\nTHis allows you to show a title and subtitle to the player.\n- Parameter - Text (`title`): The title to show, can be string or null.\n- Parameter - Text (`subtitle`): The subtitle to show, can be string or null.\n"
  },
  "Method <Player>.spectatorTeleport(entity)": {
    "prefix": ".spectatorTeleport($entity)",
    "body": ".spectatorTeleport($entity)",
    "description": "<Player>.spectatorTeleport(entity)\nThis allows you to teleport to any entity as long as you are in spectator mode.\n- Parameter - Entity (`entity`): The entity to teleport to, this can also be a string (UUID of entity).\n"
  },
  "Method <Player>.stonecutter(itemInput, itemOutput)": {
    "prefix": ".stonecutter($itemInput, $itemOutput)",
    "body": ".stonecutter($itemInput, $itemOutput)",
    "description": "<Player>.stonecutter(itemInput, itemOutput)\nThis allows you to use the stonecutter.\n- Parameter - Material (`itemInput`): The item or material you want to input.\n- Parameter - Material (`itemOutput`): The item or material you want to craft.\n"
  },
  "Method <Player>.swapHands()": {
    "prefix": ".swapHands()",
    "body": ".swapHands()",
    "description": "<Player>.swapHands()\nThis will swap the player's main hand with the off hand.\n"
  },
  "Method <Player>.swapPlayerSlotWithHotbar(slot)": {
    "prefix": ".swapPlayerSlotWithHotbar($slot)",
    "body": ".swapPlayerSlotWithHotbar($slot)",
    "description": "<Player>.swapPlayerSlotWithHotbar(slot)\nThis allows you to swap a slot in the player's inventory with the hotbar.\n- Parameter - Number (`slot`): The slot to swap.\n"
  },
  "Method <Player>.swapSlots(slot1, slot2)": {
    "prefix": ".swapSlots($slot1, $slot2)",
    "body": ".swapSlots($slot1, $slot2)",
    "description": "<Player>.swapSlots(slot1, slot2)\nThe allows you to swap two slots with one another.\nA note about slot order is that slots go from top to bottom.\nThis will throw an errof if the slots are out of bounds.\n- Parameter - Number (`slot1`): The slot to swap with slot2.\n- Parameter - Number (`slot2`): The slot to swap with slot1.\n"
  },
  "Method <Player>.swingHand(hand)": {
    "prefix": ".swingHand($hand)",
    "body": ".swingHand($hand)",
    "description": "<Player>.swingHand(hand)\nThis will play the player's hand swing animation for a given hand.\n- Parameter - String (`hand`): The hand to swing, this should be either 'main_hand' or 'off_hand'.\n"
  },
  "Method <Player>.updateBreakingBlock(pos)": {
    "prefix": ".updateBreakingBlock($pos)",
    "body": ".updateBreakingBlock($pos)",
    "description": "<Player>.updateBreakingBlock(pos)\nThis allows you to update your block breaking progress at a position.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <Player>.updateBreakingBlock(x, y, z)": {
    "prefix": ".updateBreakingBlock($x, $y, $z)",
    "body": ".updateBreakingBlock($x, $y, $z)",
    "description": "<Player>.updateBreakingBlock(x, y, z)\nThis allows you to update your block breaking progress at a position.\n- Parameter - Number (`x`): The x position.\n- Parameter - Number (`y`): The y position.\n- Parameter - Number (`z`): The z position.\n"
  },
  "Method <Player>.use(action)": {
    "prefix": ".use($action)",
    "body": ".use($action)",
    "description": "<Player>.use(action)\nThis allows you to make your player use, you must\npass 'hold', 'stop', or 'once' otherwise an error will be thrown.\n- Parameter - String (`action`): The type of action, either 'hold', 'stop', or 'once'.\n"
  },
  "Static Method Player.get()": {
    "prefix": "Player.get()",
    "body": "Player.get()",
    "description": "Player.get()\nThis gets the main player.\n"
  },
  "Pos Class": {
    "prefix": "Pos",
    "body": "Pos",
    "description": "The Pos class from Minecraft.\nThis class is a wrapper for 3 coordinate points in Minecraft.\n"
  },
  "Constructor new Pos(list)": {
    "prefix": "new Pos($list)",
    "body": "new Pos($list)",
    "description": "new Pos(list)\nCreates a new Pos object with the given coordinates in a list.\n- Parameter - List (`list`): The list containing three coordinates.\n"
  },
  "Constructor new Pos(x, y, z)": {
    "prefix": "new Pos($x, $y, $z)",
    "body": "new Pos($x, $y, $z)",
    "description": "new Pos(x, y, z)\nThis creates a new Pos with the given x, y, and z.\n- Parameter - Number (`x`): The x position.\n- Parameter - Number (`y`): The y position.\n- Parameter - Number (`z`): The z position.\n"
  },
  "Method <Pos>.add(pos)": {
    "prefix": ".add($pos)",
    "body": ".add($pos)",
    "description": "<Pos>.add(pos)\nThis returns a new Pos with the current pos x, y, and z added by the given pos x, y, and z.\n- Parameter - Pos (`pos`): The Pos to add by.\n"
  },
  "Method <Pos>.add(x, y, z)": {
    "prefix": ".add($x, $y, $z)",
    "body": ".add($x, $y, $z)",
    "description": "<Pos>.add(x, y, z)\nThis returns a new Pos with the current pos x, y, and z added by the given x, y, and z.\n- Parameter - Number (`x`): The x adder.\n- Parameter - Number (`y`): The y adder.\n- Parameter - Number (`z`): The z adder.\n"
  },
  "Method <Pos>.asCentre()": {
    "prefix": ".asCentre()",
    "body": ".asCentre()",
    "description": "<Pos>.asCentre()\nThis returns center value of the position.\n"
  },
  "Method <Pos>.crossProduct(pos)": {
    "prefix": ".crossProduct($pos)",
    "body": ".crossProduct($pos)",
    "description": "<Pos>.crossProduct(pos)\nThis returns the cross product of the current pos and the given pos.\n- Parameter - Pos (`pos`): The Pos to cross product with.\n"
  },
  "Method <Pos>.distanceTo(other)": {
    "prefix": ".distanceTo($other)",
    "body": ".distanceTo($other)",
    "description": "<Pos>.distanceTo(other)\nThis returns distance to other position.\n- Parameter - Pos (`other`): Other position.\n"
  },
  "Method <Pos>.distanceTo(x, y, z)": {
    "prefix": ".distanceTo($x, $y, $z)",
    "body": ".distanceTo($x, $y, $z)",
    "description": "<Pos>.distanceTo(x, y, z)\nThis returns distance to other x, y, z position.\n- Parameter - Number (`x`): Other position x.\n- Parameter - Number (`y`): Other position y.\n- Parameter - Number (`z`): Other position z.\n"
  },
  "Method <Pos>.dotProduct(pos)": {
    "prefix": ".dotProduct($pos)",
    "body": ".dotProduct($pos)",
    "description": "<Pos>.dotProduct(pos)\nThis returns the dot product of the current pos and the given pos.\n- Parameter - Pos (`pos`): The Pos to dot product with.\n"
  },
  "Method <Pos>.down()": {
    "prefix": ".down()",
    "body": ".down()",
    "description": "<Pos>.down()\nThis returns a new Pos with the current pos y decremented by 1.\n"
  },
  "Method <Pos>.down(number)": {
    "prefix": ".down($number)",
    "body": ".down($number)",
    "description": "<Pos>.down(number)\nThis returns a new Pos with the current pos y decremented by the given number.\n- Parameter - Number (`number`): The number to decrement by.\n"
  },
  "Method <Pos>.east()": {
    "prefix": ".east()",
    "body": ".east()",
    "description": "<Pos>.east()\nThis returns a new Pos with the current pos x incremented by 1.\n"
  },
  "Method <Pos>.east(number)": {
    "prefix": ".east($number)",
    "body": ".east($number)",
    "description": "<Pos>.east(number)\nThis returns a new Pos with the current pos x incremented by the given number.\n- Parameter - Number (`number`): The number to increment by.\n"
  },
  "Method <Pos>.getSidePos(direction)": {
    "prefix": ".getSidePos($direction)",
    "body": ".getSidePos($direction)",
    "description": "<Pos>.getSidePos(direction)\nThis returns side position value of position.\n- Parameter - String (`direction`): The direction, can be: north, south, east, west, up, down.\n"
  },
  "Method <Pos>.getX()": {
    "prefix": ".getX()",
    "body": ".getX()",
    "description": "<Pos>.getX()\nThis returns the x position of the Pos.\n"
  },
  "Method <Pos>.getY()": {
    "prefix": ".getY()",
    "body": ".getY()",
    "description": "<Pos>.getY()\nThis returns the y position of the Pos.\n"
  },
  "Method <Pos>.getZ()": {
    "prefix": ".getZ()",
    "body": ".getZ()",
    "description": "<Pos>.getZ()\nThis returns the z position of the Pos.\n"
  },
  "Method <Pos>.isNear(entity)": {
    "prefix": ".isNear($entity)",
    "body": ".isNear($entity)",
    "description": "<Pos>.isNear(entity)\nThis returns whether position to entity is less than 4.5.\n- Parameter - Entity (`entity`): The entity you want to check.\n"
  },
  "Method <Pos>.isWithin(entity, distance)": {
    "prefix": ".isWithin($entity, $distance)",
    "body": ".isWithin($entity, $distance)",
    "description": "<Pos>.isWithin(entity, distance)\nThis returns whether position to entity is less than given distance.\n- Parameter - Entity (`entity`): The entity you want to check.\n- Parameter - Number (`distance`): The distance you want to check.\n"
  },
  "Method <Pos>.multiply(pos)": {
    "prefix": ".multiply($pos)",
    "body": ".multiply($pos)",
    "description": "<Pos>.multiply(pos)\nThis returns a new Pos with the current pos x, y, and z multiplied by the given pos x, y, and z.\n- Parameter - Pos (`pos`): The Pos to multiply by.\n"
  },
  "Method <Pos>.multiply(x, y, z)": {
    "prefix": ".multiply($x, $y, $z)",
    "body": ".multiply($x, $y, $z)",
    "description": "<Pos>.multiply(x, y, z)\nThis returns a new Pos with the current pos x, y, and z multiplied by the given x, y, and z.\n- Parameter - Number (`x`): The x multiplier.\n- Parameter - Number (`y`): The y multiplier.\n- Parameter - Number (`z`): The z multiplier.\n"
  },
  "Method <Pos>.normalize()": {
    "prefix": ".normalize()",
    "body": ".normalize()",
    "description": "<Pos>.normalize()\nNormalizes the vector to have a magnitude of 1.\n"
  },
  "Method <Pos>.north()": {
    "prefix": ".north()",
    "body": ".north()",
    "description": "<Pos>.north()\nThis returns a new Pos with the current pos z incremented by 1.\n"
  },
  "Method <Pos>.north(number)": {
    "prefix": ".north($number)",
    "body": ".north($number)",
    "description": "<Pos>.north(number)\nThis returns a new Pos with the current pos z incremented by the given number.\n- Parameter - Number (`number`): The number to increment by.\n"
  },
  "Method <Pos>.offset(direction)": {
    "prefix": ".offset($direction)",
    "body": ".offset($direction)",
    "description": "<Pos>.offset(direction)\nThis returns a new Pos with the current pos x, y, and z offset by a direction.\n- Parameter - String (`direction`): The direction to offset by, must be one of: north, south, east, west, up, down.\n"
  },
  "Method <Pos>.offset(direction, distance)": {
    "prefix": ".offset($direction, $distance)",
    "body": ".offset($direction, $distance)",
    "description": "<Pos>.offset(direction, distance)\nThis returns a new Pos with the current pos x, y, and z offset by a direction and a distance.\n- Parameter - String (`direction`): The direction to offset by, must be one of: north, south, east, west, up, down.\n- Parameter - Number (`distance`): The distance to offset by.\n"
  },
  "Method <Pos>.south()": {
    "prefix": ".south()",
    "body": ".south()",
    "description": "<Pos>.south()\nThis returns a new Pos with the current pos z decremented by 1.\n"
  },
  "Method <Pos>.south(number)": {
    "prefix": ".south($number)",
    "body": ".south($number)",
    "description": "<Pos>.south(number)\nThis returns a new Pos with the current pos z decremented by the given number.\n- Parameter - Number (`number`): The number to decrement by.\n"
  },
  "Method <Pos>.subtract(pos)": {
    "prefix": ".subtract($pos)",
    "body": ".subtract($pos)",
    "description": "<Pos>.subtract(pos)\nThis returns a new Pos with the current pos x, y, and z subtracted by the given pos x, y, and z.\n- Parameter - Pos (`pos`): The Pos to subtract by.\n"
  },
  "Method <Pos>.subtract(x, y, z)": {
    "prefix": ".subtract($x, $y, $z)",
    "body": ".subtract($x, $y, $z)",
    "description": "<Pos>.subtract(x, y, z)\nThis returns a new Pos with the current pos x, y, and z subtracted by the given x, y, and z.\n- Parameter - Number (`x`): The x subtractor.\n- Parameter - Number (`y`): The y subtractor.\n- Parameter - Number (`z`): The z subtractor.\n"
  },
  "Method <Pos>.toBlockPos()": {
    "prefix": ".toBlockPos()",
    "body": ".toBlockPos()",
    "description": "<Pos>.toBlockPos()\nThis floors all of the positions values to the nearest block.\n"
  },
  "Method <Pos>.toList()": {
    "prefix": ".toList()",
    "body": ".toList()",
    "description": "<Pos>.toList()\nThis returns the Pos as a List containing the x, y, and z positions in order.\n"
  },
  "Method <Pos>.up()": {
    "prefix": ".up()",
    "body": ".up()",
    "description": "<Pos>.up()\nThis returns a new Pos with the current pos y incremented by 1.\n"
  },
  "Method <Pos>.up(number)": {
    "prefix": ".up($number)",
    "body": ".up($number)",
    "description": "<Pos>.up(number)\nThis returns a new Pos with the current pos y incremented by the given number.\n- Parameter - Number (`number`): The number to increment by.\n"
  },
  "Method <Pos>.west()": {
    "prefix": ".west()",
    "body": ".west()",
    "description": "<Pos>.west()\nThis returns a new Pos with the current pos x decremented by 1.\n"
  },
  "Method <Pos>.west(number)": {
    "prefix": ".west($number)",
    "body": ".west($number)",
    "description": "<Pos>.west(number)\nThis returns a new Pos with the current pos x decremented by the given number.\n- Parameter - Number (`number`): The number to decrement by.\n"
  },
  "Recipe Class": {
    "prefix": "Recipe",
    "body": "Recipe",
    "description": "The Recipe class from Minecraft.\nThis class represents recipes in Minecraft.\n"
  },
  "Method <Recipe>.getCraftingType()": {
    "prefix": ".getCraftingType()",
    "body": ".getCraftingType()",
    "description": "<Recipe>.getCraftingType()\nThis returns the crafting type of the recipe.\n"
  },
  "Method <Recipe>.getFullId()": {
    "prefix": ".getFullId()",
    "body": ".getFullId()",
    "description": "<Recipe>.getFullId()\nThis returns the full id of the recipe.\n"
  },
  "Method <Recipe>.getId()": {
    "prefix": ".getId()",
    "body": ".getId()",
    "description": "<Recipe>.getId()\nThis returns the id of the recipe.\n"
  },
  "Method <Recipe>.getIngredients()": {
    "prefix": ".getIngredients()",
    "body": ".getIngredients()",
    "description": "<Recipe>.getIngredients()\nThis returns all the possible ingredients of the recipe.\n"
  },
  "Method <Recipe>.getOutput()": {
    "prefix": ".getOutput()",
    "body": ".getOutput()",
    "description": "<Recipe>.getOutput()\nThis returns the output of the recipe.\n"
  },
  "Static Method Recipe.of(recipeId)": {
    "prefix": "Recipe.of(recipeId)",
    "body": "Recipe.of($recipeId)",
    "description": "Recipe.of(recipeId)\nThis converts a recipe id into a Recipe if it's valid,\notherwise an error will be thrown.\n- Parameter - String (`recipeId`): The id of the recipe to convert to a Recipe.\n"
  },
  "Screen Class": {
    "prefix": "Screen",
    "body": "Screen",
    "description": "The Screen class from Minecraft.\nThis allows you to get information about the player's current screen.\n"
  },
  "Method <Screen>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Screen>.getName()\nGets the name of the specific screen.\n"
  },
  "Method <Screen>.getTitle()": {
    "prefix": ".getTitle()",
    "body": ".getTitle()",
    "description": "<Screen>.getTitle()\nGets the title of the specific screen.\n"
  },
  "Set Class": {
    "prefix": "Set",
    "body": "Set",
    "description": "The Set class.\nSets are collections of unique values. Similar to maps, without the values.\nAn instance of the class can be created by using `Set.of(values...)`.\n"
  },
  "Constructor new Set()": {
    "prefix": "new Set()",
    "body": "new Set()",
    "description": "new Set()\nThis creates an empty set.\n"
  },
  "Method <Set>.add(value)": {
    "prefix": ".add($value)",
    "body": ".add($value)",
    "description": "<Set>.add(value)\nThis allows you to add a value to the set.\n- Parameter - Object (`value`): The value you want to add to the set.\n"
  },
  "Method <Set>.addAll(collection)": {
    "prefix": ".addAll($collection)",
    "body": ".addAll($collection)",
    "description": "<Set>.addAll(collection)\nThis allows you to add all the values in a collection into the set.\n- Parameter - Collection (`collection`): The collection of values you want to add.\n"
  },
  "Method <Set>.clear()": {
    "prefix": ".clear()",
    "body": ".clear()",
    "description": "<Set>.clear()\nThis removes all values from inside the set.\n"
  },
  "Method <Set>.contains(value)": {
    "prefix": ".contains($value)",
    "body": ".contains($value)",
    "description": "<Set>.contains(value)\nThis allows you to check whether a value is in the set.\n- Parameter - Object (`value`): The value that you want to check in the set.\n"
  },
  "Method <Set>.containsAll(collection)": {
    "prefix": ".containsAll($collection)",
    "body": ".containsAll($collection)",
    "description": "<Set>.containsAll(collection)\nThis allows you to check whether a collection of values are all in the set.\n- Parameter - Collection (`collection`): The collection of values you want to check in the set.\n"
  },
  "Method <Set>.filter(function)": {
    "prefix": ".filter($function)",
    "body": ".filter($function)",
    "description": "<Set>.filter(function)\nThis allows you to filter the set, this returns a new set.\n- Parameter - Function (`function`): The function you want to filter the set by.\n"
  },
  "Method <Set>.get(value)": {
    "prefix": ".get($value)",
    "body": ".get($value)",
    "description": "<Set>.get(value)\nThis allows you to get a value from in the set.\nThe reason this might be useful is if you want to retrieve something\nfrom the set that will have the same hashcode but be in a different state\nas the value you are passing in.\n- Parameter - Object (`value`): The value you want to get from the set.\n"
  },
  "Method <Set>.map(function)": {
    "prefix": ".map($function)",
    "body": ".map($function)",
    "description": "<Set>.map(function)\nThis allows you to map the set.\n- Parameter - Function (`function`): The function you want to map the set by.\n"
  },
  "Method <Set>.reduce(function)": {
    "prefix": ".reduce($function)",
    "body": ".reduce($function)",
    "description": "<Set>.reduce(function)\nThis allows you to reduce the set.\n- Parameter - Function (`function`): The function you want to reduce the set by.\n"
  },
  "Method <Set>.reduce(identity, reducer)": {
    "prefix": ".reduce($identity, $reducer)",
    "body": ".reduce($identity, $reducer)",
    "description": "<Set>.reduce(identity, reducer)\nThis reduces the list using the reducer starting with an identity.\n- Parameter - Object (`identity`): The identity.\n- Parameter - Function (`reducer`): A function that takes a value and returns a new value.\n"
  },
  "Method <Set>.remove(value)": {
    "prefix": ".remove($value)",
    "body": ".remove($value)",
    "description": "<Set>.remove(value)\nThis allows you to remove a value from the set.\n- Parameter - Object (`value`): The value you want to remove from the set.\n"
  },
  "Method <Set>.removeAll(value)": {
    "prefix": ".removeAll($value)",
    "body": ".removeAll($value)",
    "description": "<Set>.removeAll(value)\nThis allows you to remove all values in a collection from the set.\n- Parameter - Collection (`value`): The values you want to remove from the set.\n"
  },
  "Method <Set>.toList()": {
    "prefix": ".toList()",
    "body": ".toList()",
    "description": "<Set>.toList()\nThis returns a list of all the values in the set.\n"
  },
  "Static Method Set.of(values)": {
    "prefix": "Set.of(values)",
    "body": "Set.of($values)",
    "description": "Set.of(values)\nThis allows you to create a set with an arbitrary number of values.\n- Parameter - Object (`values`): The values you want to add to the set.\n"
  },
  "Static Method Set.unordered()": {
    "prefix": "Set.unordered()",
    "body": "Set.unordered()",
    "description": "Set.unordered()\nThis creates an unordered set.\n"
  },
  "Shape Class": {
    "prefix": "Shape",
    "body": "Shape",
    "description": "The Shape class from Minecraft.\nThis class is the base class for all shapes that can be rendered,\nproviding the base functionality for all shapes.\n"
  },
  "Method <Shape>.getBlue()": {
    "prefix": ".getBlue()",
    "body": ".getBlue()",
    "description": "<Shape>.getBlue()\nThis returns the blue value of the shape.\n"
  },
  "Method <Shape>.getGreen()": {
    "prefix": ".getGreen()",
    "body": ".getGreen()",
    "description": "<Shape>.getGreen()\nThis returns the green value of the shape.\n"
  },
  "Method <Shape>.getOpacity()": {
    "prefix": ".getOpacity()",
    "body": ".getOpacity()",
    "description": "<Shape>.getOpacity()\nThis returns the opacity of the shape.\n"
  },
  "Method <Shape>.getRGB()": {
    "prefix": ".getRGB()",
    "body": ".getRGB()",
    "description": "<Shape>.getRGB()\nThis returns the RGB value of the shape.\n"
  },
  "Method <Shape>.getRGBAList()": {
    "prefix": ".getRGBAList()",
    "body": ".getRGBAList()",
    "description": "<Shape>.getRGBAList()\nThis returns the RGBA value of the shape as a list.\n"
  },
  "Method <Shape>.getRGBList()": {
    "prefix": ".getRGBList()",
    "body": ".getRGBList()",
    "description": "<Shape>.getRGBList()\nThis returns the RGB value of the shape as a list.\n"
  },
  "Method <Shape>.getRed()": {
    "prefix": ".getRed()",
    "body": ".getRed()",
    "description": "<Shape>.getRed()\nThis returns the red value of the shape.\n"
  },
  "Method <Shape>.getXScale()": {
    "prefix": ".getXScale()",
    "body": ".getXScale()",
    "description": "<Shape>.getXScale()\nThis gets the x scale of the shape.\n"
  },
  "Method <Shape>.getXTilt()": {
    "prefix": ".getXTilt()",
    "body": ".getXTilt()",
    "description": "<Shape>.getXTilt()\nThis gets the x tilt of the shape.\n"
  },
  "Method <Shape>.getYScale()": {
    "prefix": ".getYScale()",
    "body": ".getYScale()",
    "description": "<Shape>.getYScale()\nThis gets the y scale of the shape.\n"
  },
  "Method <Shape>.getYTilt()": {
    "prefix": ".getYTilt()",
    "body": ".getYTilt()",
    "description": "<Shape>.getYTilt()\nThis gets the y tilt of the shape.\n"
  },
  "Method <Shape>.getZScale()": {
    "prefix": ".getZScale()",
    "body": ".getZScale()",
    "description": "<Shape>.getZScale()\nThis gets the z scale of the shape.\n"
  },
  "Method <Shape>.getZTilt()": {
    "prefix": ".getZTilt()",
    "body": ".getZTilt()",
    "description": "<Shape>.getZTilt()\nThis gets the z tilt of the shape.\n"
  },
  "Method <Shape>.render()": {
    "prefix": ".render()",
    "body": ".render()",
    "description": "<Shape>.render()\nThis sets the shape to be rendered indefinitely, the shape will only stop rendering when\nthe script ends or when you call the stopRendering() method.\n"
  },
  "Method <Shape>.setBlue(blue)": {
    "prefix": ".setBlue($blue)",
    "body": ".setBlue($blue)",
    "description": "<Shape>.setBlue(blue)\nThis sets the blue value of the shape, using a single value.\nIf the colour is not between 0 and 255 an error will be thrown.\n- Parameter - Number (`blue`): The amount of blue between 0 - 255.\n"
  },
  "Method <Shape>.setColour(colour)": {
    "prefix": ".setColour($colour)",
    "body": ".setColour($colour)",
    "description": "<Shape>.setColour(colour)\nThis sets the colour of the shape, using a single value, this\nfunction also has a sibling named `setColor()` that has the same functionality.\nThe colour generally should be hexadecimal in the form 0xRRGGBB.\n- Parameter - Number (`colour`): The colour you want to set.\n"
  },
  "Method <Shape>.setColour(red, green, blue)": {
    "prefix": ".setColour($red, $green, $blue)",
    "body": ".setColour($red, $green, $blue)",
    "description": "<Shape>.setColour(red, green, blue)\nThis sets the colour of the shape, using three values this function\nalso has a sibling named `setColor()` that has the same functionality.\nIf the colours are not between 0 and 255 an error will be thrown.\n- Parameter - Number (`red`): The amount of red 0 - 255.\n- Parameter - Number (`green`): The amount of green 0 - 255.\n- Parameter - Number (`blue`): The amount of blue 0 - 255.\n"
  },
  "Method <Shape>.setGreen(green)": {
    "prefix": ".setGreen($green)",
    "body": ".setGreen($green)",
    "description": "<Shape>.setGreen(green)\nThis sets the green value of the shape, using a single value.\nIf the colour is not between 0 and 255 an error will be thrown.\n- Parameter - Number (`green`): The amount of green between 0 - 255.\n"
  },
  "Method <Shape>.setOpacity(opacity)": {
    "prefix": ".setOpacity($opacity)",
    "body": ".setOpacity($opacity)",
    "description": "<Shape>.setOpacity(opacity)\nThis sets the opacity of the shape, using a single value.\nIf the colour is not between 0 and 255 an error will be thrown.\n- Parameter - Number (`opacity`): The amount of opacity between 0 - 255.\n"
  },
  "Method <Shape>.setRed(red)": {
    "prefix": ".setRed($red)",
    "body": ".setRed($red)",
    "description": "<Shape>.setRed(red)\nThis sets the red value of the shape, using a single value.\nIf the colour is not between 0 and 255 an error will be thrown.\n- Parameter - Number (`red`): The amount of red between 0 - 255.\n"
  },
  "Method <Shape>.setRenderThroughBlocks(boolean)": {
    "prefix": ".setRenderThroughBlocks($boolean)",
    "body": ".setRenderThroughBlocks($boolean)",
    "description": "<Shape>.setRenderThroughBlocks(boolean)\nThis sets whether the shape should render through blocks.\n- Parameter - Boolean (`boolean`): Whether the shape should render through blocks.\n"
  },
  "Method <Shape>.setScale(xScale, yScale, zScale)": {
    "prefix": ".setScale($xScale, $yScale, $zScale)",
    "body": ".setScale($xScale, $yScale, $zScale)",
    "description": "<Shape>.setScale(xScale, yScale, zScale)\nThis sets the scale of the shape.\n- Parameter - Number (`xScale`): The x scale of the shape.\n- Parameter - Number (`yScale`): The y scale of the shape.\n- Parameter - Number (`zScale`): The z scale of the shape.\n"
  },
  "Method <Shape>.setTilt(xTilt, yTilt, zTilt)": {
    "prefix": ".setTilt($xTilt, $yTilt, $zTilt)",
    "body": ".setTilt($xTilt, $yTilt, $zTilt)",
    "description": "<Shape>.setTilt(xTilt, yTilt, zTilt)\nThis sets the tilt of the shape.\n- Parameter - Number (`xTilt`): The x tilt.\n- Parameter - Number (`yTilt`): The y tilt.\n- Parameter - Number (`zTilt`): The z tilt.\n"
  },
  "Method <Shape>.setXScale(xScale)": {
    "prefix": ".setXScale($xScale)",
    "body": ".setXScale($xScale)",
    "description": "<Shape>.setXScale(xScale)\nThis sets the x scale of the shape.\n- Parameter - Number (`xScale`): The x scale of the shape.\n"
  },
  "Method <Shape>.setXTilt(xTilt)": {
    "prefix": ".setXTilt($xTilt)",
    "body": ".setXTilt($xTilt)",
    "description": "<Shape>.setXTilt(xTilt)\nThis sets the x tilt of the shape.\n- Parameter - Number (`xTilt`): The x tilt.\n"
  },
  "Method <Shape>.setYScale(yScale)": {
    "prefix": ".setYScale($yScale)",
    "body": ".setYScale($yScale)",
    "description": "<Shape>.setYScale(yScale)\nThis sets the y scale of the shape.\n- Parameter - Number (`yScale`): The y scale of the shape.\n"
  },
  "Method <Shape>.setYTilt(yTilt)": {
    "prefix": ".setYTilt($yTilt)",
    "body": ".setYTilt($yTilt)",
    "description": "<Shape>.setYTilt(yTilt)\nThis sets the y tilt of the shape.\n- Parameter - Number (`yTilt`): The y tilt.\n"
  },
  "Method <Shape>.setZScale(zScale)": {
    "prefix": ".setZScale($zScale)",
    "body": ".setZScale($zScale)",
    "description": "<Shape>.setZScale(zScale)\nThis sets the z scale of the shape.\n- Parameter - Number (`zScale`): The z scale of the shape.\n"
  },
  "Method <Shape>.setZTilt(zTilt)": {
    "prefix": ".setZTilt($zTilt)",
    "body": ".setZTilt($zTilt)",
    "description": "<Shape>.setZTilt(zTilt)\nThis sets the z tilt of the shape.\n- Parameter - Number (`zTilt`): The z tilt.\n"
  },
  "Method <Shape>.shouldRenderThroughBlocks()": {
    "prefix": ".shouldRenderThroughBlocks()",
    "body": ".shouldRenderThroughBlocks()",
    "description": "<Shape>.shouldRenderThroughBlocks()\nThis returns whether the shape should render through blocks.\n"
  },
  "Method <Shape>.stopRendering()": {
    "prefix": ".stopRendering()",
    "body": ".stopRendering()",
    "description": "<Shape>.stopRendering()\nThis stops the shape from rendering.\n"
  },
  "SphereShape Class": {
    "prefix": "SphereShape",
    "body": "SphereShape",
    "description": "The SphereShape class from Minecraft.\nThis class is used to create a sphere shape which can be rendered in the world.\n"
  },
  "Constructor new SphereShape(pos)": {
    "prefix": "new SphereShape($pos)",
    "body": "new SphereShape($pos)",
    "description": "new SphereShape(pos)\nThis creates a new sphere shape.\n- Parameter - Pos (`pos`): The position of the sphere.\n"
  },
  "Constructor new SphereShape(x, y, z)": {
    "prefix": "new SphereShape($x, $y, $z)",
    "body": "new SphereShape($x, $y, $z)",
    "description": "new SphereShape(x, y, z)\nThis creates a new sphere shape.\n- Parameter - Number (`x`): The x position of the sphere.\n- Parameter - Number (`y`): The y position of the sphere.\n- Parameter - Number (`z`): The z position of the sphere.\n"
  },
  "Method <SphereShape>.getSteps()": {
    "prefix": ".getSteps()",
    "body": ".getSteps()",
    "description": "<SphereShape>.getSteps()\nThis gets the number of steps the sphere will take to render.\n"
  },
  "Method <SphereShape>.setSteps(steps)": {
    "prefix": ".setSteps($steps)",
    "body": ".setSteps($steps)",
    "description": "<SphereShape>.setSteps(steps)\nThis sets the number of steps the sphere will take to render.\n- Parameter - Number (`steps`): The number of steps.\n"
  },
  "String Class": {
    "prefix": "String",
    "body": "String",
    "description": "The String class.\nThis class represents an array of characters to form a string.\nThis class cannot be instantiated directly, instead use the literal\nby using quotes. Strings are immutable in Arucas.\n"
  },
  "Constructor new String()": {
    "prefix": "new String()",
    "body": "new String()",
    "description": "new String()\nThis creates a new string object, not from the string pool, with the given string.\nThis cannot be called directly, only from child classes.\n"
  },
  "Method <String>.capitalize()": {
    "prefix": ".capitalize()",
    "body": ".capitalize()",
    "description": "<String>.capitalize()\nThis returns the string in capitalized form.\n"
  },
  "Method <String>.chars()": {
    "prefix": ".chars()",
    "body": ".chars()",
    "description": "<String>.chars()\nThis makes a list of all the characters in the string.\n"
  },
  "Method <String>.contains(string)": {
    "prefix": ".contains($string)",
    "body": ".contains($string)",
    "description": "<String>.contains(string)\nThis returns whether the string contains the given string.\n- Parameter - String (`string`): The string to check.\n"
  },
  "Method <String>.endsWith(string)": {
    "prefix": ".endsWith($string)",
    "body": ".endsWith($string)",
    "description": "<String>.endsWith(string)\nThis returns whether the string ends with the given string.\n- Parameter - String (`string`): The string to check.\n"
  },
  "Method <String>.find(regex)": {
    "prefix": ".find($regex)",
    "body": ".find($regex)",
    "description": "<String>.find(regex)\nThis finds all matches of the regex in the string,\nthis does not find groups, for that use `<String>.findGroups(regex)`.\n- Parameter - String (`regex`): The regex to search the string with.\n"
  },
  "Method <String>.findAll(regex)": {
    "prefix": ".findAll($regex)",
    "body": ".findAll($regex)",
    "description": "<String>.findAll(regex)\nThis finds all matches and groups of a regex in the matches in the string\nthe first group of each match will be the complete match and following\nwill be the groups of the regex, a group may be empty if it doesn't exist.\n- Parameter - String (`regex`): The regex to search the string with.\n"
  },
  "Method <String>.format(objects)": {
    "prefix": ".format($objects)",
    "body": ".format($objects)",
    "description": "<String>.format(objects)\nThis formats the string using the given arguments.\nThis internally uses the Java String.format() method.\nFor how to use see here: https://www.javatpoint.com/java-string-format.\n- Parameter - Object (`objects...`): The objects to insert.\n"
  },
  "Method <String>.length()": {
    "prefix": ".length()",
    "body": ".length()",
    "description": "<String>.length()\nThis returns the length of the string.\n"
  },
  "Method <String>.lowercase()": {
    "prefix": ".lowercase()",
    "body": ".lowercase()",
    "description": "<String>.lowercase()\nThis returns the string in lowercase.\n"
  },
  "Method <String>.matches(regex)": {
    "prefix": ".matches($regex)",
    "body": ".matches($regex)",
    "description": "<String>.matches(regex)\nThis returns whether the string matches the given regex.\n- Parameter - String (`regex`): The regex to match the string with.\n"
  },
  "Method <String>.replaceAll(regex, replacement)": {
    "prefix": ".replaceAll($regex, $replacement)",
    "body": ".replaceAll($regex, $replacement)",
    "description": "<String>.replaceAll(regex, replacement)\nThis replaces all the instances of a regex with the replace string.\n- Parameter - String (`regex`): The regex you want to replace.\n- Parameter - String (`replacement`): The string you want to replace it with.\n"
  },
  "Method <String>.replaceFirst(regex, replacement)": {
    "prefix": ".replaceFirst($regex, $replacement)",
    "body": ".replaceFirst($regex, $replacement)",
    "description": "<String>.replaceFirst(regex, replacement)\nThis replaces the first instance of a regex with the replace string.\n- Parameter - String (`regex`): The regex you want to replace.\n- Parameter - String (`replacement`): The string you want to replace it with.\n"
  },
  "Method <String>.reverse()": {
    "prefix": ".reverse()",
    "body": ".reverse()",
    "description": "<String>.reverse()\nThis returns the string in reverse.\n"
  },
  "Method <String>.split(regex)": {
    "prefix": ".split($regex)",
    "body": ".split($regex)",
    "description": "<String>.split(regex)\nThis splits the string into a list of strings based on a regex.\n- Parameter - String (`regex`): The regex to split the string with.\n"
  },
  "Method <String>.startsWith(string)": {
    "prefix": ".startsWith($string)",
    "body": ".startsWith($string)",
    "description": "<String>.startsWith(string)\nThis returns whether the string starts with the given string.\n- Parameter - String (`string`): The string to check.\n"
  },
  "Method <String>.strip()": {
    "prefix": ".strip()",
    "body": ".strip()",
    "description": "<String>.strip()\nThis strips the whitespace from the string.\n"
  },
  "Method <String>.subString(from, to)": {
    "prefix": ".subString($from, $to)",
    "body": ".subString($from, $to)",
    "description": "<String>.subString(from, to)\nThis returns a substring of the string.\n- Parameter - Number (`from`): The start index (inclusive).\n- Parameter - Number (`to`): The end index (exclusive).\n"
  },
  "Method <String>.toList()": {
    "prefix": ".toList()",
    "body": ".toList()",
    "description": "<String>.toList()\nThis makes a list of all the characters in the string.\n"
  },
  "Method <String>.toNumber()": {
    "prefix": ".toNumber()",
    "body": ".toNumber()",
    "description": "<String>.toNumber()\nThis tries to convert the string to a number.\nThis method can convert hex or denary into numbers.\nIf the string is not a number, it will throw an error.\n"
  },
  "Method <String>.uppercase()": {
    "prefix": ".uppercase()",
    "body": ".uppercase()",
    "description": "<String>.uppercase()\nThis returns the string in uppercase.\n"
  },
  "Task Class": {
    "prefix": "Task",
    "body": "Task",
    "description": "The Task class.\nThis class is used to create tasks that can be chained and\nrun asynchronously. Tasks can be executed as many times as needed\nand chained tasks will be executed in the order they are created.\n"
  },
  "Constructor new Task()": {
    "prefix": "new Task()",
    "body": "new Task()",
    "description": "new Task()\nThis creates a new empty task.\n"
  },
  "Method <Task>.run()": {
    "prefix": ".run()",
    "body": ".run()",
    "description": "<Task>.run()\nThis runs the task asynchronously and returns a future which can be awaited.\nThe last function in the task will be used as the return value for the future.\n"
  },
  "Method <Task>.then(function)": {
    "prefix": ".then($function)",
    "body": ".then($function)",
    "description": "<Task>.then(function)\nThis adds a function to the end of the current task.\nIf this is the last function in the task then the return\nvalue of the function will be the return value of the task.\n- Parameter - Function (`function`): The function to run at the end of the task.\n"
  },
  "Text Class": {
    "prefix": "Text",
    "body": "Text",
    "description": "The Text class from Minecraft.\nThis class is used to create formatted strings used inside Minecraft.\n"
  },
  "Method <Text>.append(otherText)": {
    "prefix": ".append($otherText)",
    "body": ".append($otherText)",
    "description": "<Text>.append(otherText)\nThis allows you to append a text instance to another text instance.\n- Parameter - Text (`otherText`): The text instance to append to.\n"
  },
  "Method <Text>.format(formatting)": {
    "prefix": ".format($formatting)",
    "body": ".format($formatting)",
    "description": "<Text>.format(formatting)\nThis allows you to add a formatting to a text instance.\nA list of formatting names can be found [here](https://minecraft.fandom.com/wiki/Formatting_codes).\nThis will throw an error if the formatting is invalid.\n- Parameter - String (`formatting`): The name of the formatting.\n"
  },
  "Method <Text>.withClickEvent(event, value)": {
    "prefix": ".withClickEvent($event, $value)",
    "body": ".withClickEvent($event, $value)",
    "description": "<Text>.withClickEvent(event, value)\nThis allows you to add a click event to a text instance.\nThe possible events are: 'open_url', 'open_file', 'run_command', 'suggest_command', 'copy_to_clipboard', 'run_function'.\nThis will throw an error if the action is invalid.\n- Parameter - String (`event`): The name of the event.\n- Parameter - String (`value`): The value associated with the event.\n"
  },
  "Method <Text>.withHoverEvent(event, value)": {
    "prefix": ".withHoverEvent($event, $value)",
    "body": ".withHoverEvent($event, $value)",
    "description": "<Text>.withHoverEvent(event, value)\nThis allows you to add a hover event to a text instance.\nThe possible events are: 'show_text', 'show_item', 'show_entity'.\nThis will throw an error if the event is invalid.\n- Parameter - String (`event`): The name of the event.\n- Parameter - Object (`value`): The value associated with the event.\n"
  },
  "Static Method Text.of(string)": {
    "prefix": "Text.of(string)",
    "body": "Text.of($string)",
    "description": "Text.of(string)\nThis converts a string into a text instance.\n- Parameter - String (`string`): The string to convert into a text instance.\n"
  },
  "Static Method Text.parse(textJson)": {
    "prefix": "Text.parse(textJson)",
    "body": "Text.parse($textJson)",
    "description": "Text.parse(textJson)\nThis converts a text json into a text instance.\n- Parameter - String (`textJson`): The string in json format, or a Json value itself.\n"
  },
  "Thread Class": {
    "prefix": "Thread",
    "body": "Thread",
    "description": "The Thread class.\nThis class allows to to create threads for async executions.\nThis class cannot be instantiated or extended. To create a new\nthread use the static method 'Thread.runThreaded()'.\n"
  },
  "Method <Thread>.freeze()": {
    "prefix": ".freeze()",
    "body": ".freeze()",
    "description": "<Thread>.freeze()\nThis serves the same purpose as 'Thread.freeze()' however this works on the current\nthread instance, unlike 'Thread.freeze()' this cannot throw an error.\n"
  },
  "Method <Thread>.getAge()": {
    "prefix": ".getAge()",
    "body": ".getAge()",
    "description": "<Thread>.getAge()\nThis gets the age of the thread in milliseconds.\n"
  },
  "Method <Thread>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Thread>.getName()\nThis gets the name of the thread.\n"
  },
  "Method <Thread>.isAlive()": {
    "prefix": ".isAlive()",
    "body": ".isAlive()",
    "description": "<Thread>.isAlive()\nThis checks if the thread is alive (still running).\n"
  },
  "Method <Thread>.stop()": {
    "prefix": ".stop()",
    "body": ".stop()",
    "description": "<Thread>.stop()\nThis stops the thread from executing, anything that was running will be instantly stopped.\nThis method will fail if the thread is not alive.\n"
  },
  "Method <Thread>.thaw()": {
    "prefix": ".thaw()",
    "body": ".thaw()",
    "description": "<Thread>.thaw()\nThis will thaw the thread from its frozen state, if the thread is not frozen then an\nerror will be thrown.\n"
  },
  "Static Method Thread.freeze()": {
    "prefix": "Thread.freeze()",
    "body": "Thread.freeze()",
    "description": "Thread.freeze()\nThis freezes the current thread, stops anything else from executing on the thread.\nThis may fail if you try to freeze a non Arucas Thread in which case an error will be thrown.\n"
  },
  "Static Method Thread.getCurrentThread()": {
    "prefix": "Thread.getCurrentThread()",
    "body": "Thread.getCurrentThread()",
    "description": "Thread.getCurrentThread()\nThis gets the current thread that the code is running on,\nthis may throw an error if the thread is not safe to get,\nwhich happens when running outside of Arucas Threads.\n"
  },
  "Static Method Thread.runThreaded(function)": {
    "prefix": "Thread.runThreaded(function)",
    "body": "Thread.runThreaded($function)",
    "description": "Thread.runThreaded(function)\nThis starts a new thread and runs a function on it, the thread will\nterminate when it finishes executing the function, threads will stop automatically\nwhen the program stops, you are also able to stop threads by using the Thread object.\n- Parameter - Function (`function`): The function you want to run on a new thread.\n"
  },
  "Static Method Thread.runThreaded(name, function)": {
    "prefix": "Thread.runThreaded(name, function)",
    "body": "Thread.runThreaded($name, $function)",
    "description": "Thread.runThreaded(name, function)\nThis starts a new thread with a specific name and runs a function on it.\n- Parameter - String (`name`): The name of the thread.\n- Parameter - Function (`function`): The function you want to run on a new thread.\n"
  },
  "Trade Class": {
    "prefix": "Trade",
    "body": "Trade",
    "description": "The Trade class from Minecraft.\nThis class represents a trade offer, and allows you to get information about it.\n"
  },
  "Method <Trade>.getAdjustedFirstBuyItem()": {
    "prefix": ".getAdjustedFirstBuyItem()",
    "body": ".getAdjustedFirstBuyItem()",
    "description": "<Trade>.getAdjustedFirstBuyItem()\nGets the first item that the merchant will buy, adjusted by the price multiplier.\n"
  },
  "Method <Trade>.getFirstBuyItem()": {
    "prefix": ".getFirstBuyItem()",
    "body": ".getFirstBuyItem()",
    "description": "<Trade>.getFirstBuyItem()\nGets the first item that the merchant will buy.\n"
  },
  "Method <Trade>.getMaxUses()": {
    "prefix": ".getMaxUses()",
    "body": ".getMaxUses()",
    "description": "<Trade>.getMaxUses()\nGets the maximum number of times the trade can be used.\n"
  },
  "Method <Trade>.getPriceMultiplier()": {
    "prefix": ".getPriceMultiplier()",
    "body": ".getPriceMultiplier()",
    "description": "<Trade>.getPriceMultiplier()\nGets the price multiplier which is used to adjust the price of the first buy item.\n"
  },
  "Method <Trade>.getSecondBuyItem()": {
    "prefix": ".getSecondBuyItem()",
    "body": ".getSecondBuyItem()",
    "description": "<Trade>.getSecondBuyItem()\nGets the second item that the merchant will buy.\n"
  },
  "Method <Trade>.getSellItem()": {
    "prefix": ".getSellItem()",
    "body": ".getSellItem()",
    "description": "<Trade>.getSellItem()\nGets the item that is being sold by the merchant.\n"
  },
  "Method <Trade>.getSpecialPrice()": {
    "prefix": ".getSpecialPrice()",
    "body": ".getSpecialPrice()",
    "description": "<Trade>.getSpecialPrice()\nThis gets the special price which is used to adjust the price of the first buy item.\n"
  },
  "Method <Trade>.getUses()": {
    "prefix": ".getUses()",
    "body": ".getUses()",
    "description": "<Trade>.getUses()\nGets the number of times the trade has been used.\n"
  },
  "Method <Trade>.getXpReward()": {
    "prefix": ".getXpReward()",
    "body": ".getXpReward()",
    "description": "<Trade>.getXpReward()\nReturns the amount of xp the villager will get, which\ngoes towards them levelling up, from trading this offer.\n"
  },
  "Type Class": {
    "prefix": "Type",
    "body": "Type",
    "description": "The Type class.\nThis class lets you get the type of another class.\n"
  },
  "Method <Type>.getName()": {
    "prefix": ".getName()",
    "body": ".getName()",
    "description": "<Type>.getName()\nThis gets the name of the type.\n"
  },
  "Method <Type>.inheritsFrom(type)": {
    "prefix": ".inheritsFrom($type)",
    "body": ".inheritsFrom($type)",
    "description": "<Type>.inheritsFrom(type)\nThis checks whether a type is a subtype of another type.\n- Parameter - Type (`type`): The other type you want to check against.\n"
  },
  "Static Method Type.of(value)": {
    "prefix": "Type.of(value)",
    "body": "Type.of($value)",
    "description": "Type.of(value)\nThis gets the specific type of a value.\n- Parameter - Object (`value`): The value you want to get the type of.\n"
  },
  "World Class": {
    "prefix": "World",
    "body": "World",
    "description": "The World class from Minecraft.\nThis class represents worlds, and allows you to interact with things inside of them.\n"
  },
  "Method <World>.getAllEntities()": {
    "prefix": ".getAllEntities()",
    "body": ".getAllEntities()",
    "description": "<World>.getAllEntities()\nThis will get all entities in the world.\n"
  },
  "Method <World>.getAllOtherPlayers()": {
    "prefix": ".getAllOtherPlayers()",
    "body": ".getAllOtherPlayers()",
    "description": "<World>.getAllOtherPlayers()\nThis will get all other players in the world.\n"
  },
  "Method <World>.getAllPlayers()": {
    "prefix": ".getAllPlayers()",
    "body": ".getAllPlayers()",
    "description": "<World>.getAllPlayers()\nThis function gets all players in the world that are loaded.\n"
  },
  "Method <World>.getArea(pos1, pos2)": {
    "prefix": ".getArea($pos1, $pos2)",
    "body": ".getArea($pos1, $pos2)",
    "description": "<World>.getArea(pos1, pos2)\nThis gets a list of all block positions between the two positions.\n- Parameter - Pos (`pos1`): The first position.\n- Parameter - Pos (`pos2`): The second position.\n"
  },
  "Method <World>.getAreaOfBlocks(pos1, pos2)": {
    "prefix": ".getAreaOfBlocks($pos1, $pos2)",
    "body": ".getAreaOfBlocks($pos1, $pos2)",
    "description": "<World>.getAreaOfBlocks(pos1, pos2)\nThis gets a list of all blocks (with positions) between the two positions.\n- Parameter - Pos (`pos1`): The first position.\n- Parameter - Pos (`pos2`): The second position.\n"
  },
  "Method <World>.getBiomeAt(pos)": {
    "prefix": ".getBiomeAt($pos)",
    "body": ".getBiomeAt($pos)",
    "description": "<World>.getBiomeAt(pos)\nThis function gets the biome at the given coordinates.\n- Parameter - Pos (`pos`): The position.\n"
  },
  "Method <World>.getBiomeAt(x, y, z)": {
    "prefix": ".getBiomeAt($x, $y, $z)",
    "body": ".getBiomeAt($x, $y, $z)",
    "description": "<World>.getBiomeAt(x, y, z)\nThis function gets the biome at the given coordinates.\n- Parameter - Number (`x`): The x coordinate.\n- Parameter - Number (`y`): The y coordinate.\n- Parameter - Number (`z`): The z coordinate.\n"
  },
  "Method <World>.getBlockAt(pos)": {
    "prefix": ".getBlockAt($pos)",
    "body": ".getBlockAt($pos)",
    "description": "<World>.getBlockAt(pos)\nThis function gets the block at the given coordinates.\n- Parameter - Pos (`pos`): The position.\n"
  },
  "Method <World>.getBlockAt(x, y, z)": {
    "prefix": ".getBlockAt($x, $y, $z)",
    "body": ".getBlockAt($x, $y, $z)",
    "description": "<World>.getBlockAt(x, y, z)\nThis function gets the block at the given coordinates.\n- Parameter - Number (`x`): The x coordinate.\n- Parameter - Number (`y`): The y coordinate.\n- Parameter - Number (`z`): The z coordinate.\n"
  },
  "Method <World>.getBlockLight(pos)": {
    "prefix": ".getBlockLight($pos)",
    "body": ".getBlockLight($pos)",
    "description": "<World>.getBlockLight(pos)\nGets the block light at the given position ignoring sky light.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <World>.getBlocks(pos1, pos2)": {
    "prefix": ".getBlocks($pos1, $pos2)",
    "body": ".getBlocks($pos1, $pos2)",
    "description": "<World>.getBlocks(pos1, pos2)\nThis gets an iterator for all blocks (and positions) between two positions.\n- Parameter - Pos (`pos1`): The first position.\n- Parameter - Pos (`pos2`): The second position.\n"
  },
  "Method <World>.getBlocksFromCentre(centre, xRange, yRange, zRange)": {
    "prefix": ".getBlocksFromCentre($centre, $xRange, $yRange, $zRange)",
    "body": ".getBlocksFromCentre($centre, $xRange, $yRange, $zRange)",
    "description": "<World>.getBlocksFromCentre(centre, xRange, yRange, zRange)\nThis gets an iterator for all blocks (and positions) between two positions.\nThe iterator iterates from the centre outwards.\n- Parameter - Pos (`centre`): The central position.\n- Parameter - Number (`xRange`): How far to iterate on the x axis.\n- Parameter - Number (`yRange`): How far to iterate on the y axis.\n- Parameter - Number (`zRange`): How far to iterate on the z axis.\n"
  },
  "Method <World>.getClosestPlayer(entity, maxDistance)": {
    "prefix": ".getClosestPlayer($entity, $maxDistance)",
    "body": ".getClosestPlayer($entity, $maxDistance)",
    "description": "<World>.getClosestPlayer(entity, maxDistance)\nThis will get the closest player to another entity in the world.\n- Parameter - Entity (`entity`): The entity to get the closest player to.\n- Parameter - Number (`maxDistance`): The maximum distance to search for a player in blocks.\n"
  },
  "Method <World>.getDimensionName()": {
    "prefix": ".getDimensionName()",
    "body": ".getDimensionName()",
    "description": "<World>.getDimensionName()\nThis will get the id of the world.\n"
  },
  "Method <World>.getEmittedRedstonePower(pos, direction)": {
    "prefix": ".getEmittedRedstonePower($pos, $direction)",
    "body": ".getEmittedRedstonePower($pos, $direction)",
    "description": "<World>.getEmittedRedstonePower(pos, direction)\nGets the emitted restone power at the given position and direction.\n- Parameter - Pos (`pos`): The position of the block.\n- Parameter - String (`direction`): The direction to check, for example 'north', 'east', 'up', etc.\n"
  },
  "Method <World>.getEmittedRedstonePower(x, y, z, direction)": {
    "prefix": ".getEmittedRedstonePower($x, $y, $z, $direction)",
    "body": ".getEmittedRedstonePower($x, $y, $z, $direction)",
    "description": "<World>.getEmittedRedstonePower(x, y, z, direction)\nGets the emitted restone power at the given position and direction.\n- Parameter - Number (`x`): The x position of the block.\n- Parameter - Number (`y`): The y position of the block.\n- Parameter - Number (`z`): The z position of the block.\n- Parameter - String (`direction`): The direction to check, for example 'north', 'east', 'up', etc.\n"
  },
  "Method <World>.getEntityFromId(entityId)": {
    "prefix": ".getEntityFromId($entityId)",
    "body": ".getEntityFromId($entityId)",
    "description": "<World>.getEntityFromId(entityId)\nThis will get an entity from the given entity id.\n- Parameter - Number (`entityId`): The entity id.\n"
  },
  "Method <World>.getFullId()": {
    "prefix": ".getFullId()",
    "body": ".getFullId()",
    "description": "<World>.getFullId()\nThis will get the full id of the world.\n"
  },
  "Method <World>.getId()": {
    "prefix": ".getId()",
    "body": ".getId()",
    "description": "<World>.getId()\nThis will get the id of the world.\n"
  },
  "Method <World>.getLight(pos)": {
    "prefix": ".getLight($pos)",
    "body": ".getLight($pos)",
    "description": "<World>.getLight(pos)\nGets the light level at the given position, takes the max of either sky light of block light.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <World>.getLight(x, y, z)": {
    "prefix": ".getLight($x, $y, $z)",
    "body": ".getLight($x, $y, $z)",
    "description": "<World>.getLight(x, y, z)\nGets the light level at the given position, takes the max of either sky light of block light.\n- Parameter - Number (`x`): The x position of the block.\n- Parameter - Number (`y`): The y position of the block.\n- Parameter - Number (`z`): The z position of the block.\n"
  },
  "Method <World>.getOtherPlayer(username)": {
    "prefix": ".getOtherPlayer($username)",
    "body": ".getOtherPlayer($username)",
    "description": "<World>.getOtherPlayer(username)\nThis gets another player from the given username.\n- Parameter - String (`username`): The username of the other player.\n"
  },
  "Method <World>.getPlayer(name)": {
    "prefix": ".getPlayer($name)",
    "body": ".getPlayer($name)",
    "description": "<World>.getPlayer(name)\nThis function gets the player with the given name.\n- Parameter - String (`name`): The name of the player.\n"
  },
  "Method <World>.getPositions(pos1, pos2)": {
    "prefix": ".getPositions($pos1, $pos2)",
    "body": ".getPositions($pos1, $pos2)",
    "description": "<World>.getPositions(pos1, pos2)\nThis gets an iterator for all positions between two positions.\n- Parameter - Pos (`pos1`): The first position.\n- Parameter - Pos (`pos2`): The second position.\n"
  },
  "Method <World>.getPositionsFromCentre(centre, xRange, yRange, zRange)": {
    "prefix": ".getPositionsFromCentre($centre, $xRange, $yRange, $zRange)",
    "body": ".getPositionsFromCentre($centre, $xRange, $yRange, $zRange)",
    "description": "<World>.getPositionsFromCentre(centre, xRange, yRange, zRange)\nThis gets an iterator for all positions between two positions.\nThe iterator iterates from the centre outwards.\n- Parameter - Pos (`centre`): The central position.\n- Parameter - Number (`xRange`): How far to iterate on the x axis.\n- Parameter - Number (`yRange`): How far to iterate on the y axis.\n- Parameter - Number (`zRange`): How far to iterate on the z axis.\n"
  },
  "Method <World>.getSkyLight(pos)": {
    "prefix": ".getSkyLight($pos)",
    "body": ".getSkyLight($pos)",
    "description": "<World>.getSkyLight(pos)\nGets the sky light at the given position ignoring block light.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <World>.getTimeOfDay()": {
    "prefix": ".getTimeOfDay()",
    "body": ".getTimeOfDay()",
    "description": "<World>.getTimeOfDay()\nThis will get the time of day of the world\ninfo on the time of day [here](https://minecraft.fandom.com/wiki/Daylight_cycle).\n"
  },
  "Method <World>.isAir(pos)": {
    "prefix": ".isAir($pos)",
    "body": ".isAir($pos)",
    "description": "<World>.isAir(pos)\nReturns true if the block at the given position is air.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <World>.isAir(x, y, z)": {
    "prefix": ".isAir($x, $y, $z)",
    "body": ".isAir($x, $y, $z)",
    "description": "<World>.isAir(x, y, z)\nReturns true if the block at the given position is air.\n- Parameter - Number (`x`): The x position of the block.\n- Parameter - Number (`y`): The y position of the block.\n- Parameter - Number (`z`): The z position of the block.\n"
  },
  "Method <World>.isLoaded(pos)": {
    "prefix": ".isLoaded($pos)",
    "body": ".isLoaded($pos)",
    "description": "<World>.isLoaded(pos)\nThis function returns loaded state of given coordinates(client side).\n- Parameter - Pos (`pos`): The position.\n"
  },
  "Method <World>.isRaining()": {
    "prefix": ".isRaining()",
    "body": ".isRaining()",
    "description": "<World>.isRaining()\nThis will check if the world is currently raining.\n"
  },
  "Method <World>.isThundering()": {
    "prefix": ".isThundering()",
    "body": ".isThundering()",
    "description": "<World>.isThundering()\nThis will check if the world is currently thundering.\n"
  },
  "Method <World>.reloadChunks()": {
    "prefix": ".reloadChunks()",
    "body": ".reloadChunks()",
    "description": "<World>.reloadChunks()\nThis reloads all the chunks, as if you were to press F3 + A.\n"
  },
  "Method <World>.renderParticle(particleId, pos)": {
    "prefix": ".renderParticle($particleId, $pos)",
    "body": ".renderParticle($particleId, $pos)",
    "description": "<World>.renderParticle(particleId, pos)\nThis will render a particle in the world, you can find a list of all\nthe particle ids [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Particles),\nthis will throw an error if the id is invalid.\n- Parameter - String (`particleId`): The id of the particle.\n- Parameter - Pos (`pos`): The position of the particle.\n"
  },
  "Method <World>.renderParticle(particleId, x, y, z)": {
    "prefix": ".renderParticle($particleId, $x, $y, $z)",
    "body": ".renderParticle($particleId, $x, $y, $z)",
    "description": "<World>.renderParticle(particleId, x, y, z)\nThis will render a particle in the world, you can find a list of all\nthe particle ids [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Particles),\nif the id is invalid it will throw an error.\n- Parameter - String (`particleId`): The id of the particle.\n- Parameter - Number (`x`): The x position of the particle.\n- Parameter - Number (`y`): The y position of the particle.\n- Parameter - Number (`z`): The z position of the particle.\n"
  },
  "Method <World>.renderParticle(particleId, pos, velX, velY, velZ)": {
    "prefix": ".renderParticle($particleId, $pos, $velX, $velY, $velZ)",
    "body": ".renderParticle($particleId, $pos, $velX, $velY, $velZ)",
    "description": "<World>.renderParticle(particleId, pos, velX, velY, velZ)\nThis will render a particle in the world with a velocity, you can find a list of all\nthe particle ids [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Particles),\nthis will throw an error if the id is invalid.\n- Parameter - String (`particleId`): The id of the particle.\n- Parameter - Pos (`pos`): The position of the particle.\n- Parameter - Number (`velX`): The velocity of the particle on the x axis.\n- Parameter - Number (`velY`): The velocity of the particle on the y axis.\n- Parameter - Number (`velZ`): The velocity of the particle on the z axis.\n"
  },
  "Method <World>.setGhostBlock(block, pos)": {
    "prefix": ".setGhostBlock($block, $pos)",
    "body": ".setGhostBlock($block, $pos)",
    "description": "<World>.setGhostBlock(block, pos)\nThis sets a ghost block in the world as if it were a real block, may cause issues.\n- Parameter - Block (`block`): The block to set.\n- Parameter - Pos (`pos`): The position of the block.\n"
  },
  "Method <World>.setGhostBlock(block, x, y, z)": {
    "prefix": ".setGhostBlock($block, $x, $y, $z)",
    "body": ".setGhostBlock($block, $x, $y, $z)",
    "description": "<World>.setGhostBlock(block, x, y, z)\nThis sets a ghost block in the world as if it were a real block, may cause issues.\n- Parameter - Block (`block`): The block to set.\n- Parameter - Number (`x`): The x position of the block.\n- Parameter - Number (`y`): The y position of the block.\n- Parameter - Number (`z`): The z position of the block.\n"
  }
}